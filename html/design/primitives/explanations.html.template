<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Design</title>
    <%= stylesheets('ucll', 'box') %>
    <%= scripts('jquery', 'jquery-ui', 'underscore', 'box', 'ace/ace', 'source-editor') %>
    <style>
      img.large {
        width: 60%;
      }

      table.centered {
        margin: 10px auto;
      }

      table th {
        width: 30%;
        text-align: left;
        background: #AAA;
        padding: 2px;
      }

      dt {
        font-weight: bold;
      }
    </style>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      
      function initialize()
      {
        Box.initialize();
      }

      $( initialize );    
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      <div class="center-vertically">Design</div>
    </header>
    <div id="contents">
      <section>
        <h1>Disclaimer</h1>
        <p>
          This page delves into the technical details of how primitives are designed. Since the final design
          has some complexity to it, we will build up to it and not tell you the whole truth right away.
          Instead, we start off with a simple design that we will modify as we go on.
        </p>
      </section>
      
      <section>
        <h1>The Composite Design Pattern</h1>
        <p>
          The <code>Primitive</code> hierarchy relies heavily on the
          <a href="https://en.wikipedia.org/wiki/Composite_pattern">Composite design pattern</a>.
          For those unfamiliar with the concept, we will first explore a different class hierarchy
          that you should already have experience with.
        </p>

        <section>
          <h2>Examples</h2>
          <section>
            <h3>Design of GUI Libraries</h3>
            <p>
              How are GUIs represented using object-oriented design? Simple: by composition.
            </p>
            <p>
              First, you get access to basic building blocks: buttons, text boxes, check boxes, labels, etc.
              Next, you get a means of putting these together into larger whole.
              For example, using WPF terminology, a <code>StackPanel</code> allows
              you to put GUI controls next to each other, either horizontally or vertically.
              A <code>Grid</code> allows you to layout controls in a grid-like fashion.
              You can see these panels as "operations" on GUI controls, a bit like the "addition" of two controls
              yielding a new, bigger control.
            </p>
            <p>
              There are many such "operations" available:
            </p>
            <ul>
              <li>
                The <code>Border</code> control has the very limited task of,
                given a child control, to draw a border around it.
              </li>
              <li>
                A <code>ScrollViewer</code> can be used on a large control so as to make
                it possible to choose which part of it should be visible on screen.
              </li>
              <li>
                A <code>ViewBox</code> takes a child control and scales it.
              </li>
            </ul>
            <p>
              The most important aspect of the Composite design pattern is its <em>recursiveness</em>.
              In other words, if you apply an operation (be it a Panel, a ViewBox, a Border, or whatever) on a control, the result
              is once again a control, on which you can then proceed to apply the same operations again. For example, you can have a <code>Button</code>,
              you can apply the <code>Border</code> operation on it, and then again, and then once more, and you'll have a button with three borders.
              This three-bordered button can then be put inside a panel, which can be put inside a <code>ViewBox</code>, etc.
              This recursiveness, i.e. that every operation on controls yields a new control, allows you to build
              arbitrarily large GUIs.
            </p>
          </section>

          <section>
            <h3>Classes and Objects</h3>
            <p>
              Classes and objects follow the same principle. Here, the basic building blocks are the primitive types:
              <code>int</code>, <code>char</code>, <code>bool</code>, &hellip; Classes allow you to group these together
              into new types, and these new types can then be used in the construction of other types, and so on.
            </p>
            <p>
              Imagine what would happen if this were not the case: say a class can only contain primitive types.
              This would be quite restrictive, making large programs much more difficult to create.
            </p>
          </section>
        </section>

        <section>
          <h2>Primitives: Basic Building Blocks</h2>
          <p>
            So, how do we apply the same principles on primitives? Let's first try to find out what the basic building blocks are,
            and then which operations can be performed on them.
          </p>
          <p>
            The basic building blocks are geometric shapes. Games, for example, use only one such shape as building, namely the triangle.
            Technically, this is enough to build even the <%= link('extensions/primitives/mesh', 'most complex of shapes') %>: you just have to make the triangles very tiny
            and have enough of them. While it may seem simpler to only have to implement one shape, you have to remember
            that you'll still have to find a way to produce all the right triangles, so you're just shifting the complexity elsewhere.
          </p>
          <p>
            In other words, it is easier to implement both <code>Triangle</code> and <code>Sphere</code> than to just
            implement <code>Triangle</code> and build a <code>Sphere</code> out of it. Working with a single sphere
            is also much more efficient than to have to work with thousands of tiny triangles.
          </p>
          <p>
            So, what will our basic shapes be? Well, any shape that have a simple enough mathematical formula. Examples are:
          </p>
          <ul>
            <li>Spheres</li>
            <li><%= link('extensions/primitives/plane', 'Planes') %></li>              
            <li><%= link('extensions/primitives/cylinder', 'Cylinders') %></li>
            <li><%= link('extensions/primitives/cone', 'Cones') %></li>
            <li><%= link('extensions/primitives/triangle', 'Triangles') %> (you weren't planning on building triangles out of many tiny spheres, were you?)</li>
            <li><%= link('extensions/primitives/disk', 'Disks') %></li>
            <li><%= link('extensions/primitives/square', 'Squares') %></li>
            <li><%= link('extensions/primitives/cube', 'Cubes') %></li>
          </ul>
          <p>
            These basic shapes are so primitive that (in our design) you cannot even change their size or position in space (except for triangles.)
            For example, you can only create spheres with radius 1 that are centered at $(0, 0, 0)$.
          </p>
        </section>

        <section>
          <h3>Transformations</h3>
          <p>
            This brings us to the operations we can apply on these primitives. There are actually many types of operations available,
            some more abstract than others. The most straightforward operations are transformations:
          </p>
          <ul>
            <li>Translation</li>
            <li><%= link('extensions/primitives/scaling', 'Scaling') %></li>
            <li><%= link('extensions/primitives/rotation', 'Rotation') %></li>
          </ul>
          <p>
            So, even though spheres themselves only come in size 1, you can use scaling to make them as big or as small as you want.
            This approach has the advantage that it makes the implementation much simpler. It is certainly possible to
            create a <code>Sphere</code> class whose constructor takes a center and radius parameter, but the mathematical formula
            behind it will be more complex.
          </p>
          <p>
            For example, take the cylinder primitive. For an arbitrary cylinder with radius $R$ whose axis has direction $\vec N$ and goes through some point $P$,
            the formula is
            \[
            \left(O + \vec\Delta \cdot t - \frac{O + \vec\Delta \cdot t - P}{\vec N \cdot \vec N} \cdot \vec N\right) \cdot \left(O + \vec\Delta \cdot t - \frac{O + \vec\Delta \cdot t - P}{\vec N \cdot \vec N} \cdot \vec N\right) = R^2
            \]
            This is quite an intimidating formula. If, however, we choose to only support vertical cylinders (i.e. $\vec N = (0, 1, 0)$ and $P = (0,0,0)$) with radius 1 ($R = 1$), this formula can be simplified considerably.
          </p>
          <p>
            In summary, although this approach requires us to write more classes, they are much easier to write since they
            each have very limited responsibilities. Each class can also be tested separately, further simplifying our job.
          </p>
        </section>

        <section>
          <h3>Combining Shapes</h3>
          <p>
            We have discussed the basic building blocks (sphere, cylinder, cone, &hellip;) and
            transformations (translating, scaling, rotating). This merely allows us to
            create scenes consisting of a single shape, but hey, look at the bright side,
            it can be as big as you want.
          </p>
          <p>
            In order to allow for scenes built out of more than one shape, we need
            some "grouping" operation, like panels in GUI libraries. For this,
            we provide <a href="https://en.wikipedia.org/wiki/Constructive_solid_geometry">Constructive Solid Geometry</a> operations.
          </p>
          <ul>
            <li>
              <%= link('extensions/primitives/union', 'Unions') %> allows you to have multiple primitives in the scene, i.e.
              the union of two spheres is&hellip; two spheres.
            </li>
            <li>
              <%= link('extensions/primitives/intersection', 'Intersections') %>
            </li>
            <li>
              <%= link('extensions/primitives/difference', 'Difference') %>
            </li>
          </ul>
          <p>
            These operations together with transformations allow you to craft any shape you want.
          </p>
        </section>

        <section>
          <h3>Decorators and Materials</h3>
          <p>
            Another important operation on primitives is the <em>decorator</em> which assigns a <em>material</em> to a primitive.
            By default, a basic shape has no material assigned to it, meaning it has no color (not even black),
            no reflectance properties, etc. It is therefore an error to try to render an undecorated shape.
          </p>
          <p>
            We can define any kind of materials. Examples are
          </p>
          <ul>
            <li>
              <%= link('extensions/materials/marble', 'Marble') %>
            </li>
            <li>
              <%= link('extensions/materials/dalmatian', 'Dalmation spots') %>
            </li>
            <li>
              <%= link('extensions/materials/texture', 'Textures') %>
            </li>
          </ul>
        </section>

        <section>
          <h3>Example</h3>
          <p>
            Consider the scene shown below.
          </p>
          <%= raytrace_movie 'example' %>
          <p>
            It is described by the following hierarchy:
          </p>
          <%= tex_image 'example-hierarchy' %>
          <p>
            In the animation above, you can see two separate objects:
            a plane with a grid drawn on it and a green lens. The union at the
            top of the hierarchy has as sole purpose of grouping the plane and lens together.
            Both the plane and the lens need to be decorated; as you can see,
            there's indeed a separate decorator for both. We omitted the details of the material.
            The plane material is responsible for the grid pattern, while the lens's material
            specifies that the lens is green and refracts light.
          </p>
          <p>
            The lens is placed above the plane. We can achieve this in multiple ways:
            we could lower the plane or raise the lens. We decided to move the plane downwards.
          </p>
          <p>
            Lastly, we need to create the lens. The lens is not a basic shape, but it can be
            created by intersecting two spheres: we create two spheres, move one a bit to the left,
            the other to the right, and we only keep their intersection.
          </p>
          <p>
            The following C++ code performs all necessary steps to create this scene. Take some time to see how it works.
          </p>
          <%= source 'example.cpp' %>
          <p>
            The ray tracer is also equipped with a <a href="http://chaiscript.com/">scripting language</a>.
            Using this language is much more practical: if you were to create each scene in C++,
            you'd have both to deal with C++'s complexity and long compilation times.
            Using the scripting language avoids all of C++'s pitfalls, plus it requires no compilation.
            In this scripting language, the same scene would look as follows:
          </p>
          <%= source 'example.chai' %>
        </section>
      </section>

      <section>
        <h1>Classes</h1>
        <p>
          We now focus on how primitives are implemented. First, a warning: we will not immediately be telling you the
          whole truth, but instead explain in steps how the design has evolved. Hopefully, this will result in you have a better understanding
          of the final design.
        </p>
        <p>
          We've been talking incessentantly about primitives that it should come as no surprise
          that there is a superclass representing this concept. So, let's start with an abstract superclass <code>Primitive</code>.
          Methods are not important for now, so there's nothing else to say for the moment about <code>Primitive</code> itself.
        </p>
        <p>
          The basic shapes such as sphere, plane, cone, and cylinder are as you would expect subclasses of <code>Primitive</code>.
        </p>
        <%= tex_image('shape-hierarchy', html_class:'centered', style: 'width: 30%;') %>
        <p>
          Things get more interesting with transformations. A transformation is something that takes a <code>Primitive</code>
          and is in itself also a <code>Primitive</code>. Compare this to mathematical operators: the addition
          takes two values, and is in itself also a value.
        </p>
        <%= tex_image('transformation-hierarchy', html_class:'centered', style: 'width: 50%;') %>
        <p>
          Notice the following details:
        </p>
        <ul>
          <li>
            Each <code>Transformation</code> object keeps a link to a <code>Primitive</code>.
          </li>
          <li>
            Each <code>Transformation</code> object is itself a <code>Primitive</code>. This is where the power of the composite design pattern lies.
          </li>
          <li>
            <code>Rotation</code> is split up into three specialized rotations: around the X-axis, around the Y-axis and around the Z-axis.
          </li>
        </ul>
        <p>
          For example, creating a 2-radius sphere centered at (1, 2, 3) requires the creation of three objects:
          a <code>Sphere</code>, a <code>Translation</code> and a <code>Scaling</code> object. C++ code creating
          these objects would look like this:
        </p>
        <%= source 'sphere-example.cpp' %>
        <p>
          Because each transformation is in itself a primitive, we can keep applying multiple transformations in row. Without this recursiveness,
          we could not have translated the scaling.
        </p>
        <p>
          Remember though that these classes belong the the <code>primitives</code> module, so the classes are private to that module.
          The only functionality the module exposes is the ability to create objects of these classes:
        </p>
        <%= source 'primitives-api.cpp' %>
        <p>
          Now, we've always told you that working with pointers directly is generally a bad idea, on account of them
          being so brittle. It'd be much better were we to use the more robust <code>std::shared_ptr</code>, so
          the public interface of the <code>primitives</code> module looks like this:
        </p>
        <%= source 'primitives-api-shared-ptrs.cpp' %>
        <p>
          While this is technically a better solution, it is also excessively verbose.
          Luckily, C++ allows for type aliases. Let's introduce an alias for <code>std::shared_ptr&lt;Primitive&gt;</code>:
        </p>
        <%= source 'primitives-api-alias.cpp' %>
        <p>
          Now, this is rather silly. <code>Primitive</code> is meant to be hidden, while <code>PPrimitive</code> is exposed.
          Why give the clumsy name to the type that we'll actually have to use?
        </p>
        <p>
          It would make more sense to give the private type an "ugly" name and the public type a user-friendly one:
        </p>
        <%= source 'primitives-api-wrappers.cpp' %>
        <p>
          Now, <code>Primitive</code> is the public type, while <code>PrimitiveImplementation</code> is the private one.
          This is the naming used in the RayTracer's design. There is one small difference though: instead
          of <code>Primitive</code> being an alias for <code>std::shared_ptr&lt;PrimitiveImplementation&gt;</code>,
          it is a small <%= link 'design/wrappers', 'wrapper class' %>, but this makes almost no difference.
        </p>
      </section>
      
      <section>
        <h1>Functionality</h1>
      </section>
    </div>
  </body>
  <script>
    function initialize()
    {
      Box.initialize();
      SourceEditor.initialize();
    }

    $( initialize );   
  </script>
</html>
