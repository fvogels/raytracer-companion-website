= Mesh

// TODO

[WARNING]
====
This page still needs to change.
You should wait until this message has disappeared to avoid doing unnecessary work.
====

== Rendering Complex Shapes

=== Linear Approximations in 2D

Let's say you're making a 2D game on very old hardware.
You would like to draw this shape:

image::circle.png[align="center",width="25%"]

The attentive reader will notice this is a circle.
However, circles are rather computationally expensive to draw.
Maybe you can find another way?

Lines.
Lines are cheap.
Let's try to approximate our circle using line segments.

image::approx4.png[align="center",width="25%"]

Well, it's an approximation all right.
But it will have to do: your hardware can't handle any better.
However, when you're able to get your hands on something more powerful, you can easily improve your "circle":

[.center,options="header",cols="^.^1,^5",width="60%"]
|===
| Vertex count | Result
| 8 a| image::approx8.png[align="center",width="50%"]
| 16 a| image::approx16.png[align="center",width="50%"]
| 32 a| image::approx32.png[align="center",width="50%"]
| 64 a| image::approx64.png[align="center",width="50%"]
|===

What's nice about this approximation trick is that it is applicable on any shape, however complex it may be.
You can make an arbitrarily close approximation by simply throwing more line segments at it.

=== Linear Approximations in 3D

In 3D, line segments will not do.
We need something better.
Instead of line segments, we use "plane segments".
Or triangles, if you will.

Here they are in action:

video::preview.mp4[align="center"]

We call such a collection of triangles a _mesh_.
Any shape can be built out of triangles, as long as you have enough of them.
For example, our friend the happy Buddha above is built out of a 1,087,716 triangles.

== Dealing with Large Meshes

The problem with having meshes consisting of millions of triangles is obvious: rendering times go through the roof.
We need to find a way to speed it up quite a bit if we want to be able to admire the results within our lifetime.

There are many ways to speed things up.
You are free to implement any approach you wish, but in these pages, we will discuss one particular technique, namely bounding boxes.

The idea behind bounding boxes is simple.
Say you have a mesh consisting of a million triangles, then for every ray shot out of the eye, you normally would compute its intersection with each of the million triangles, which amounts to a lot of work.
We desperately want to cut that number down.

We can achieve that by enclosing all those triangles into a tight-fitting box.
Then, for each ray, we would first check if the ray intersects with the box.
If it doesn't, the ray will not intersect any triangles inside the box.
We just saved ourselves a million hit-checks.
Of course, if the ray _does_ intersect the box, we're back to square one and have to deal with all million triangles.

[source,language="python"]
----
def is_hit(ray, box):
  if ray hits box:
    # Assumes that the contents of the box are all triangles
    return any(is_triangle_hit(ray, triangle) for triangle in box.contents)
  else:
    return False
----

[NOTE,caption="Example"]
====
image::bbh1.png[align="center",width="50%"]

Let's say the mesh consists of stem:[N] triangles.
We build a nice box around them.
The green ray flies by the box containing all triangles.
Only one intersection test is necessary, namely the one with the box.

The red ray, however, does hit the box, so all stem:[N] triangles have to be considered in turn.
Result: stem:[N+1] intersection tests are necessary.
====

We could, however, add more boxes.
Say we divide the large all-encompassing box into two additional smaller boxes: the upper half and the lower half.
Each box would contain approximately half a million triangles.
Then, if the ray intersects the large box, we check which of the two smaller boxes it intersects.
If we're lucky, the ray misses one of the smaller boxes and we avoided half a million hit-checks.

[source,language="python"]
----
def is_hit(ray, object):
  if isinstance(object, Triangle):
    return is_triangle_hit(ray, object)
  else:
    # Note the recursive call: a child can be a BoundingBox
    return any(is_hit(ray, child) for child in object.contents)
----

[NOTE,caption="Example"]
====
image::bbh2.png[align="center",width="50%"]

Again we have stem:[N] triangles.
We put them in one big box.
But inside the big box, we add two smaller boxes, each containing stem:[N/2] triangles.

* The green ray misses the outer box, so only 1 intersection check necessary.
* The blue ray hits the outer box (1 intersection check).
  We check the two inner boxes (2 more intersection checks).
  The left box is hit, so we need to go through all triangles in the left box (stem:[N+2] intersection checks).
  Total: stem:[N/2 + 3] checks.
* The red ray is less lucky.
  We first check if it hits the outer box (1 check), it does.
  Then, we check the two inner boxes (2 checks) and we see it hits both.
  All triangles need to be processed (stem:[N] checks).
  Total: stem:[N+3] checks.
====

We can continue this process recursively: we split each box into smaller boxes, thereby creating a bounding box hierarchy.
We continue to do so until each single box contains only a small number of triangles.
When tracing a ray, we only need to consider the contents of boxes it actually intersects.
This way, instead of having to process a million triangles, we can get away with, say, a hundred.

The building of this bounding box hierarchy takes time.
Fortunately, this needs to be done only once per mesh: once done, we can write the box hierarchy to file and read it whenever the mesh pops up in a scene.
This means, however, that we need to build a tool separate from the ray tracer, one that reads in all triangles, builds the bounding box hierarchy and stores it into a file.

== Actual Implementation

Let's take a step back and review what we need to do.

* First, we need a mesh.
  This mesh will be unoptimized and be nothing more than a large collection of triangles.
* This data will have to be stored in a file.
  We'd like an easy to read file format.
  Let's use the extension `.unoptimized.mesh` for now.
* The mesh needs to be optimized, i.e., we need to arrange the triangles in some bounding box hierarchy.
  This should be done by a separate tool, which can be implemented in any language.
* The new optimized mesh must also be stored in a file.
  This file format will need to be able to encode bounding box hierarchies.
  We can use the `.optimized.mesh` extension.
* Finally, we will need to be able to read this `.optimized.mesh` file in our ray tracer so as to be able to actually render the mesh.

image::process.svg[align="center",width="40%"]

=== Finding a Mesh

We _could_ https://www.blender.org[create our own meshes], but that'd be a lot of work.
Instead, we can just pick a mesh:

[.center,cols="^.^,^.^,^",options="header",width="60%"]
|===
| Name | #Triangles | Preview
| Bunny       | 69451      a| video::bunny.mp4[width="100%"]
| Iron Man    | 217038     a| video::ironman.mp4[width="100%"]
| Buddha      | 1087716    a| video::buddha.mp4[width="100%"]
|===

=== Unoptimized Mesh Format

There are multiple ways to store meshes:

* https://en.wikipedia.org/wiki/STL_(file_format)[.stl file format]
* https://en.wikipedia.org/wiki/Wavefront_.obj_file[Wavefront .obj file format]
* https://en.wikipedia.org/wiki/PLY_(file_format)[.ply file format]

However, we can be smart about our file format choice.
An unoptimized mesh can be seen as a bunch of triangles grouped in a single box, whereas an optimized mesh adds more depth to the hierarchy (boxes of boxes of boxes of ... of triangles).
This would allow us to use the same format for both unoptimized and optimized meshes.

=== Mesh Format

As discussed in the previous section, we only really need a single format for both unoptimized and optimized meshes.
We can therefore use a single extension `.mesh`.

There's more good news: we have already defined the format for you.
Added to this, you are also provided with a {cpp} class that parses it.
However, you still need to know what the format looks like though: your mesh optimizer needs to be able both to read and write a mesh file.

==== Working Example

First, a bit of explanation so that the mesh format makes more sense.
As you know, a mesh consists of many triangles.
If we were to construct a disk out of triangles, it would look like this:

image::disk.png[align="center",width="25%"]

This disk is made out of 36 triangles.
For the sake of clarity, we simplify this disk to just 4 triangles:

image::vertex-sharing.png[align="center",width="50%"]

==== Naive File Format

Our simplified disk is built out of 4 triangles, each having 3 vertices, each of which have 3 coordinates (x, y, z), each of which are ``double``s which are 8 bytes long, meaning we need to store 4 &times; 3 &times; 3 &times; 8 = 288 bytes.
We could encode this disk as follows:

[source,language="python"]
----
0 0 0    1  0 0    0  1 0      # Triangle 0
0 0 0    0  1 0   -1  0 0      # Triangle 1
0 0 0   -1  0 0    0 -1 0      # Triangle 2
0 0 0    0 -1 0    1  0 0      # Triangle 3
----

==== Improved File Format

Notice, however, that the middle vertex is shared by all triangles, and that all other vertices are shared by two triangles.
In total, there are only 5 unique vertices.
We can make use of this to save on storage.
First, we list all the vertices:

[source,language="python"]
----
 0  0  0   # #0: Central vertex
 1  0  0   # #1: East vertex
 0  1  0   # #2: North vertex
-1  0  0   # #3: West vertex
 0 -1  0   # #4: South vertex
----

Next, we specify the triangles by simply listing their vertices using their index.

[source,language="python"]
----
0 1 2    # Triangle 0 connects vertex 0, vertex 1 and vertex 2
0 2 3    # Triangle 1 connects vertex 0, vertex 2 and vertex 3
0 3 4    # Triangle 2 connects vertex 0, vertex 3 and vertex 4
0 4 1    # Triangle 3 connects vertex 0, vertex 4 and vertex 1
----

Let's count how many bytes of storage we need now.

* First, we listed all 5 vertices, each requiring 3 &times; 8 bytes, which amount to 120 bytes.
* Next, we defined 4 triangles, each using 3 vertex indices.
  These indices are regular ``int``s, so 4 bytes each.
  This means the triangles themselves take up 4 &times; 3 &times; 4 = 48 bytes.
* Total: 120 + 48 = 168 bytes.
  This is much less than the original 288 bytes.

If we were to make the same calculation for the original disk that we built out of 36 triangles, we get 2592 bytes vs 1320 bytes.

There's one problem though: how is a file reader supposed to know where the vertices end and where the triangles start?
Luckily, the solution is simple: we simply add an integer at the very top of the file that tells the reader how many vertices there are.
The entire file thus becomes

[source,language="python"]
----
5            # Number of vertices
 0  0  0     # #0: Central vertex
 1  0  0     # #1: East vertex
 0  1  0     # #2: North vertex
-1  0  0     # #3: West vertex
 0 -1  0     # #4: South vertex
0 1 2        # Triangle 0 connects vertex 0, vertex 1 and vertex 2
0 2 3        # Triangle 1 connects vertex 0, vertex 2 and vertex 3
0 3 4        # Triangle 2 connects vertex 0, vertex 3 and vertex 4
0 4 1        # Triangle 3 connects vertex 0, vertex 4 and vertex 1
----

==== Adding Boxes

Using our file format, we can only specify triangles.
It's great for unoptimized meshes, but as discussed above, we also want to be able to encode bounding box hierarchies.



// === Step One: Finding Meshes

// First, you need to find a mesh to render.
// You can build one yourself using a 3D modelling tool such as https://www.blender.org[Blender], or you could just look for a premade one online.
// We've provided you with a few meshes link:/meshes[meshes].

// Just like there are many different graphics formats (png, jpeg, bmp, &hellip;), there exists a diversity of mesh formats such as ply, obj, etc.


// If you want to make use of one of these formats, it is your responsibility to find out how to read them.

// Since reading in a mesh file is not our focus, the <%= raw_link('meshes', 'meshes we provide', check: false) %>
// are stored in a very simple file format. In order to understand it, you must know what it's meant to contain:
// triangles. The most straightforward format would be to store one triangle per line: ``x1 y1 z1 x2 y2 z2 x3 y3 z3``.
// However, since some meshes are composed of millions of triangles, mesh files would quickly grow very large, literally GBs in size.

// There is a rather easy way to reduce a mesh's storage requirements: a vertex is generally shared by multiple triangles.

// image::vertices.svg[align="center"]

// In the picture above, the centered vertex is shared by four triangles, while all others

// * The first line contains an integer V representing the number of vertices.
// * The next V lines contain three floating point numbers. These represent the XYZ coordinates of V vertices.
// * The next line contains a single integer T. This represents the number of triangles.
// * Lastly, T lines containing three integers i, j and k follow. Each line represents a triangle whose vertices are denoted by their indices.

// For example, the following file encodes a mesh consisting of a single triangle:

// [source,language=text]
// ----
// 3
// 0 0 0
// 1.5 2.1 3.2
// -1.2 1.1 5.6
// 1
// 0 1 2
// ----

// === Step Two: Creating the Bounding Box Hierarchy

// This step involves creating a separate tool that

// * reads in the mesh found in step one,
// * builds the bounding box hierarchy, and
// * stores the result in a file.

// There are <</reference/primitives/mesh/optimization/explanations#,many ways>> to build a hierarchy:
// you can work top down (starting with a large box and dividing it into smaller boxes) or bottom
// up (starting with small boxes and combining them into large boxes). There is no single right way
// to build the hierarchy. To compare algoritmhs, we can measure

// * The time it takes to build a hierarchy.
// * The time it takes to render the mesh.

// Since the first part (building the hierarchy) needs only occur once, the rendering
// times are by far the most important aspect.

// Storing the bounding box hierarchy in a file can again be done in many ways.
// First, you'll have to choose between text or binary format. Using text format
// is a bit easier, but much slower.

// Next, you have to encode the vertices, triangles and bounding boxes.
// Let's focus solely on the latter two. Say you have the following hierarchy:

// image::hierarchy.svg[align="center"]

// One way would be to work with a stack based format: you start off with an empty stack.
// Whenever a triangle is added, it is added to this stack. Whenever a box is defined,
// the last two items on the stack are popped of, put in a box, which in turn
// is again pushed on the stack. For the diagram shown above, this results in:

// [source,language=text]
// ----
// triangle i1 j1 k1       # Vertex-indices of T1
// triangle i2 j2 k2       # Vertex-indices of T2
// box                     # Groups last two triangles together
// triangle i3 j3 k3
// triangle i4 j4 k4
// box
// box                     # Groups last two boxes together
// triangle i5 j5 k5
// triangle i6 j6 k6
// box
// triangle i7 j7 k7
// triangle i8 j8 k8
// box
// box
// box
// ----

// Another possibility is to work with indices, similarly to how triangles and vertices work:
// triangles and boxes are numbered, and a box refers to what it contains using indices.
// This yields

// [source,language=text]
// ----
// triangle i1 j1 k1       # Index 0
// triangle i2 j2 k2       # Index 1
// box 0 1                 # Index 2
// triangle i3 j3 k3       #       3
// triangle i4 j4 k4       #       4
// box 3 4                 #       5
// box 2 5                 #       6
// triangle i5 j5 k5       #       7
// triangle i6 j6 k6       #       8
// box 7 8                 #       9
// triangle i7 j7 k7       #       10
// triangle i8 j8 k8       #       11
// box 10 11               #       12
// box 9 12                #       13
// box 6 13                #       14
// ----

// === Step Three: Rendering the Mesh

// The last step consists of extending the ray tracer with an extra type of primitive, i.e., the mesh.
// This involves reading the file produced in step 2 and using it to create triangles
// and bounding box accelerators based on its contents.
