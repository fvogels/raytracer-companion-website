= Animations

== The Quintessential Animation

An animation is "something" that changes in time. This something can be a simple ``double``,
an ``Angle``, a ``Point3D``, &hellip;

Let us consider the most basic of animations: the ``double`` animation that
goes from ``0`` to ``1`` in ``1`` second.
If we are to visualize this, we would get:

image::double-animation.png[layout="center"]

The animation is actually a <em>function</em> mapping time values to ``double`` values.
Let's denote this function with stem:[X(t)]. We can translate the properties above to mathematical formulae:
in the very beginning, the animated ``double`` should have value stem:[0]. This is expressed by

[stem]
++++
X(0) = 0
++++

Next, we know the animation takes 1 second to finish and that the ``double``
should have value stem:[1] at that time:

[stem]
++++
X(1) = 1
++++

Now, there are many ways in which we could want to modify this animation.
For example, we assumed that the ``double`` moves "in a straight line" from ``0`` to ``1``.
Other possibilities would be

[cols="^,^,^"]
|===
| image:quad-in.png[]
| image:quad-out.png[]
| image:bounce.png[]
|===

We may also want to change the starting and ending value of the animation, e.g. have a ``double`` go
from ``10`` to ``20``. The duration is also an aspect we may wish to modify.

While we could bundle all parameters together into one 'superanimation', we prefer to keep things modular.

== Formula for the Basic Animation

Before modifying the basic animation, let's first focus on the mathematical formula behind it.

We know the animation goes in a straight line, meaning stem:[X(t)] has the form stem:[m \cdot t + q] where
stem:[m] and stem:[q] can be deduced from the constraints stem:[X(0) = 0] and stem:[X(1) = 1]. We get
[stem]
++++
X(t) = t
++++
which is a pretty simple formula.

== Changing the Range

Say we don't want to animate from ``0`` to ``1``, but from
``10`` to ``20``, or better, from stem:[a] to stem:[b]. We can achieve this
easily by mapping the interval stem:[[0, 1]] to stem:[[a, b]].

image::range-mapping.png[align="center"]

We build another function, stem:[f], that can do this for us. Again this is linear function:

[stem]
++++
f(x) = m \cdot x + q \qquad f(0) = a \qquad f(1) = b
++++

which gives

[stem]
++++
f(x) = a + (b - a) \cdot x
++++

How can we combine this function stem:[f] with the basic animation stem:[X(t)] to produce
an animation from stem:[a] to stem:[b]? Simple: we first animate stem:[0] to stem:[1] and
use stem:[f] to map the value to stem:[ [a, b] ]. Let's call this new animation stem:[X_2(t)].

[stem]
++++
X_2(t) = f(X(t)) = f \circ X
++++

== Changing the Domain

The basic animation takes one second to complete. What if we want a shorter or longer animation?

Say we want the animation to take stem:[\tau] seconds. Our time will then vary from stem:[0] to stem:[\tau], whereas
the basic animation expects it to vary from stem:[0] to stem:[1]. We somehow need to translate "our time" to the "basic animation's time".
Again we can do this with a linear transformation:

image::domain-mapping.png[align="center"]

Let's assign the name stem:[g] to the function that maps the interval stem:[[0, \tau]] to stem:[[0,1]].

[stem]
++++
g(t) = \frac{t}{\tau}
++++

Given our basic animation stem:[X(t)], which moves from stem:[0] to stem:[1] in 1 second,
we can transform it to an animation stem:[X_3(t)] that goes from stem:[0] to stem:[1] in stem:[\tau] seconds as follows:

[stem]
++++
X_3(t) = X(g(t)) = X \circ g
++++

== Changing the Shape

The basic animation is linear: it moves from stem:[0] to stem:[1] at constant speed. However,
if we were to chain animations, the transition from one animation to the next
would be perceived as very abrupt. Compare the animations below:

[cols="^,^"]
|===
| image:abrupt.png[]
| image:smooth.png[]
|===

Animations can be made smoother using <em>easing functions</em>. Below are a few examples:

[cols="^,^,^"]
|===
| image:quad-in.png[]
| image:quad-out.png[]
| image:bounce.png[]
|===

An easing function stem:[e(x)] is a function for which

[stem]
++++
e(0) = 0 \qquad e(1) = 1
++++

How it moves from stem:[0] to stem:[1] is up to the easing function.

If we want to apply some easing function stem:[e(x)] to the basic animation stem:[X(t)] yielding the new animation stem:[X_3(t)], we use the following formula:

[stem]
++++
X_3(t) = X(e(t)) = X \circ e
++++

== Putting It All Together

Using the range mapper stem:[f], the domain mapper stem:[g] and the easing function stem:[e] we can transform the basic animation any way we want:

[stem]
++++
f(X(g(e(t)))) = f \circ X \circ g \circ e
++++

We can build a library of range mappers, domain mappers and easing functions and use them to produce any animation we want.

== Building Animations

The ``double`` animation is the basic building block for all animations: all other animations can be built from it.
Let's introduce a convenient notation to denote ``double`` animations:

[stem]
++++
X(t) = x \xrightarrow{\tau} y
++++

represents a ``double`` animation from stem:[x] to stem:[y] in stem:[\tau] seconds. We ignore the shape of the animation for now, i.e.
we disregard easing functions.

Say we now want to create ``Point3D`` animation stem:[P(t)]: we wish a movement
from stem:[(0, 0, 10)] to stem:[(0, 5, 0)]. The animation of a ``Point3D``
is the animation of its components, i.e. its x, y and z-coordinates:

[stem]
++++
  (0, 0, 10) \xrightarrow{\tau} (0,5,0) \quad=\quad (0 \xrightarrow{\tau} 0, 0 \xrightarrow{\tau} 5, 10 \xrightarrow{\tau} 0)
++++

or, more generally,

[stem]
++++
  (x, y, z) \xrightarrow{\tau} (x',y',z') \quad=\quad (x \xrightarrow{\tau} x', y \xrightarrow{\tau} y', z \xrightarrow{\tau} z')
++++

We can animate colors or any other type of value the same way:

[stem]
++++
  \begin{array}{rcl}
    (r, g, b) \xrightarrow{\tau} (r', g', b') & = & (r \xrightarrow{\tau} r', g \xrightarrow{\tau} g', b \xrightarrow{\tau} b') \\ \\
    50^\circ \xrightarrow{\tau} 100^\circ & = & (50 \xrightarrow{\tau} 100)^\circ
   \end{array}
++++
