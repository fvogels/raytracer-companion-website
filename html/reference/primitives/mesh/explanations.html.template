<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Mesh</title>
    <%= stylesheets('3dcg', 'box2') %>
    <%= scripts('jquery', 'jquery-ui', 'underscore', 'ace/ace', 'source-editor') %>
    <style>
      img.large {
        width: 60%;
      }

      video {
        margin: 10px auto;
      }
    </style>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      Mesh
    </header>
    <div id="contents">
      <section>
        <h1>Rendering Complex Shapes</h1>
        <p>
          A mesh is a large collection of triangles forming a complex shape. Any shape can be built out of triangles,
          as long as you have enough of them. For example, the preview below is built out of 10 million triangles.
        </p>
        <%= raytrace_movie 'demo' %>
        <p>
          The problem with having meshes consisting of millions of triangles is obvious: rendering times go through the roof.
          We need to find a way to speed it up quite a bit if we want to be able to admire the results within our lifetime.
        </p>
        <p>
          There are many ways to speed things up. You are free to implement any approach you wish, but
          in these pages, we will discuss one particular technique, namely bounding boxes.
        </p>
        <p>
          The idea behind bounding boxes is simple. Say you have a mesh consisting of a million triangles,
          then for every ray shot out of the eye, you normally would compute its intersection with each
          of the million triangles, which amounts to a lot of work. We want to cut that number down.
          We can achieve that by enclosing all those triangles into a tight-fitting box. Then,
          for each ray, we would first check if the ray intersects with the box. If it doesn't,
          the ray will not intersect any triangles inside the box. We just saved ourselves a million hit-checks.
          Of course, if the ray does intersect the box, we're back to square one and have
          to deal with all million triangles.
        </p>
        <p>
          We could, however, add more boxes. Say we divide the large all-encompassing box into two additional
          smaller boxes: the upper half and the lower half. Each box would contain approximately half a million triangles.
          Then, if the ray intersects the large box, we check which of the two smaller boxes it intersects.
          If we're lucky, the ray misses one of the smaller boxes and we avoided half a million hit-checks.
        </p>
        <p>
          We can continue this process recursively: we split each box into smaller boxes, thereby
          creating a bounding box hierarchy. We continue to do so until each single box contains
          only a small number of triangles. When tracing a ray, we only need to consider
          the contents of boxes it actually intersects. This way, instead of having to process
          a million triangles, we can get away with, say, a hundred.
        </p>
        <p>
          The building of this bounding box hierarchy takes time. Fortunately, this needs to be done only once for each mesh:
          once done, we can write the hierarchy to file and read it whenever the mesh pops up in a scene.
          This means, however, that we need to build a tool separate from the ray tracer, one that
          reads in all triangles, builds the bounding box hierarchy and stores it to file.
          The ray tracer itself will have to be extended with a module that is able to read this file
          back in and use it to rebuild the mesh.
        </p>
      </section>
      <section>
        <h2>Step One: Finding Meshes</h2>
        <p>
          First, you need to find a mesh to render. You can build one yourself using
          a 3D modelling tool such as <a href="https://www.blender.org/">Blender</a>, or
          you could just look for a premade one online. We've provided you with a few
          meshes <%= raw_link('meshes', 'here', check: false) %>.
        </p>
        <p>
          Just like there are many different graphics formats (png, jpeg, bmp, &hellip;),
          there exists a diversity of mesh formats such as ply, obj, etc.
          If you want to make use of one of these formats, it is your responsibility
          to find out how to read them.
        </p>
        <p>
          Since reading in a mesh file is not our focus, the <%= raw_link('meshes', 'meshes we provide', check: false) %>
          are stored in a very simple file format. In order to understand it, you must know what it's meant to contain:
          triangles. The most straightforward format would be to store one triangle per line: ``x1 y1 z1 x2 y2 z2 x3 y3 z3``.
          However, since some meshes are composed of millions of triangles, mesh files would quickly grow very large, literally GBs in size.
        </p>
        <p>
          There is a rather easy way to reduce a mesh's storage requirements: a vertex is generally shared by multiple triangles.
        </p>
        <svg width="400" height="400" style="background: white; margin: 1em auto; display: block">
          <%=
             ps = [ '100,80', '210,20', '380,250', '50,350' ]

             (0...ps.size).map do |i|
                 %Q{<polygon points="#{ps[i]} 200,200 #{ps[(i+1)%ps.size]}" style="stroke:black; stroke-width: 2; fill:white" />}
             end.join("\n")
          %>
        </svg>
        <p>
          In the picture above, the centered vertex is shared by four triangles, while all others
          are shared by two. To benefit from this sharing, triangles are stored as follows:
        </p>
        <ul>
          <li>
            The first line contains an integer V representing the number of vertices.
          </li>
          <li>
            The next V lines contain three floating point numbers. These represent the XYZ coordinates of V vertices.
          </li>
          <li>
            The next line contains a single integer T. This represents the number of triangles.
          </li>
          <li>
            Lastly, T lines containing three integers i, j and k follow. Each line represents a triangle whose vertices are
            denoted by their indices.
        </ul>
        <p>
          For example, the following file encodes a mesh consisting of a single triangle:
        </p>
        <%= source_editor IO.read('mesh-example.txt') %>
      </section>
      <section>
        <h2>Step Two: Creating the Bounding Box Hierarchy</h2>
        <p>
          This step involves creating a separate tool that
        </p>
        <ul>
          <li>reads in the mesh found in step one,</li>
          <li>builds the bounding box hierarchy, and</li>
          <li>stores the result in a file.</li>
        </ul>
        <p>
          There are <%= link 'reference/primitives/mesh/optimization', 'many ways' %> to build a hierarchy:
          you can work top down (starting with a large box and dividing it into smaller boxes) or bottom
          up (starting with small boxes and combining them into large boxes). There is no single right way
          to build the hierarchy. To compare algoritmhs, we can measure
        </p>
        <ul>
          <li>
            The time it takes to build a hierarchy.
          </li>
          <li>
            The time it takes to render the mesh.
          </li>
        </ul>
        <p>
          Since the first part (building the hierarchy) needs only occur once, the rendering
          times are by far the most important aspect.
        </p>
        <p>
          Storing the bounding box hierarchy in a file can again be done in many ways.
          First, you'll have to choose between text or binary format. Using text format
          is a bit easier, but much slower.
        </p>
        <p>
          Next, you have to encode the vertices, triangles and bounding boxes.
          Let's focus solely on the latter two. Say you have the following hierarchy:
        </p>
        <svg width="600" height="200" style="margin: 1em auto; display: block">
          <%=
             (0..7).map do |i|
               <<-END
                   <g transform="translate(#{i*70+50} 100)">
                     <polygon style="fill: black" points="0,-15 8,0 -8,0" />
                     <text x="0" y="15" text-anchor="middle">T#{i}</sub></text>
                   </g>
               END
             end.join("\n")
          %>
          <rect x="40" y="80" width="90" height="40" style="stroke:black;fill:red; opacity: 0.2;" />
          <rect x="180" y="80" width="90" height="40" style="stroke:black;fill:red; opacity: 0.2;" />
          <rect x="320" y="80" width="90" height="40" style="stroke:black;fill:red; opacity: 0.2;" />
          <rect x="460" y="80" width="90" height="40" style="stroke:black;fill:red; opacity: 0.2;" />
          
          <rect x="30" y="70" width="250" height="60" style="stroke:black;fill:red; opacity: 0.2;" />
          <rect x="310" y="70" width="250" height="60" style="stroke:black;fill:red; opacity: 0.2;" />

          <rect x="20" y="60" width="550" height="80" style="stroke:black;fill:red; opacity: 0.2;" />
        </svg>
        <p>
          One way would be to work with a stack based format: you start off with an empty stack.
          Whenever a triangle is added, it is added to this stack. Whenever a box is defined,
          the last two items on the stack are popped of, put in a box, which in turn
          is again pushed on the stack. For the diagram shown above, this results in:
        </p>
        <%= source_editor IO.read('stack-based.txt') %>
        <p>
          Another possibility is to work with indices, similarly to how triangles and vertices work:
          triangles and boxes are numbered, and a box refers to what it contains using indices.
          This yields
        </p>
        <%= source_editor IO.read('index-based.txt') %>
      </section>
      <section>
        <h2>Step Three: Rendering the Mesh</h2>
        <p>
          The last step consists of extending the ray tracer with an extra type of primitive, i.e., the mesh.
          This involves reading the file produced in step 2 and using it to create triangles
          and bounding box accelerators based on its contents.
        </p>
      </section>
    </div>
  </body>

  <script>
    function initialize()
    {
      SourceEditor.initialize();
    }

    $( initialize );   
  </script>
</html>
