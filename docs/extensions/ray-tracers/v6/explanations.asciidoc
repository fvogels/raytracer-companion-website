= Ray Tracer v6

[overview]
----
difficulty 3
requires ray-tracers/v5
----

preview::preview[]

== Background Information

Reflection is conceptually very simple, but implementing it requires some modifications to the ray tracer structure.
Fortunately, no changes will need to be made to existing ray tracers; all structural changes can be local to v6.

When a light ray reaches a reflective material, part of it gets reflected in a mirror-like fashion.

image::reflection.png[align="center"]

As always with ray tracing, we need to work backwards.
How does reflection fit into the ray tracing process?

* We wish to know what light arrives from a certain direction.
  We construct a ray starting in our eye stem:[E] and has the right direction.
* The ray hits the scene at some position stem:[P] of some object.
  Whatever color this object has on position stem:[P] is the color we see.
  However, we notice the material at that location happens to be reflective.
* We make the ray bounce off the object's surface.
  This produces a new ray which we can again trace.
  The result of this new tracing determines what color gets reflected at stem:[P].

image::reflection2.png[align="center"]

In the diagram above, both the color of stem:[P] and stem:[P'] will arrive in stem:[E].

== Recursive Ray Tracing

Implementing reflection works as follows:

[source,language='python']
----
def trace(scene, ray):
  hit = scene.find_first_positive_hit(eye_ray)

  if hit:
    matprops = ...
    color = determine_color(scene, matprops, hit, eye_ray)
  else:
    return no_hit


def determine_color(scene, matprops, hit, eye_ray):
  result = black

  # Add ambient
  result += compute_ambient(...)

  # Add diffuse, specular
  result += process_light_sources(...)

  # Add reflection
  result += compute_reflection(...) //<1>

  return result


def compute_reflection(scene, matprops, hit, eye_ray):
  # Bounce off the object's surface
  reflected_ray = reflection of eye_ray at hit.position

  # Start the tracing algorithm all over again
  return trace(scene, reflected_ray) //<2>
----
1. After ambient, diffuse and specular lighting, reflection is added as a fourth source of photons.
2. Notice the recursive call.

== Reflectivity

There are two details we need to take into account:

* Infinite recursion can occur if a ray gets caught between reflective materials.
* Materials are not necessarily 100% reflective.
  As mentioned before, only _part_ of the photons get reflected.

One solution solves both problems: we associate a _reflectivity_ with each material, which is a number between ``0`` and ``1`` indicating how great a fraction of photons get reflected.
A nonreflective material has reflectivity ``0``, a perfect mirror has reflectivity ``1``.

We update the pseudocode to take into account reflectivity:

[source,language='python']
----
def trace(scene, ray):
  hit = scene.find_first_positive_hit(eye_ray)

  if hit:
    matprops = ...
    color = determine_color(scene, matprops, hit, eye_ray)
  else:
    return no_hit


def determine_color(scene, matprops, hit, eye_ray):
  result = black

  # Add ambient
  result += compute_ambient(...)

  # Add diffuse, specular
  result += process_light_sources(...)

  # Add reflection
  result += compute_reflection(...)

  return result


def compute_reflection(scene, matprops, hit, eye_ray):
  # Bounce off the object's surface
  reflected_ray = reflection of eye_ray at hit.position

  # Start the tracing algorithm all over again
  return matprops.reflectivity * trace(scene, reflected_ray) // <1>
----
1. Because `0 &le; reflectivity &le; 1`, ``trace``'s result is reduced, or at best kept unchanged.

[TASK]
====
* Add an extra field `reflectivity` to `MaterialProperties`.
* Add an extra constructor parameter to initialize this `reflectivity`.
====

[TASK]
====
Update the `MaterialPropertiesBuilder`.
====

[TASK]
====
Update the script bindings in `scripting/materials-module.cpp`.
====

== Preventing Infinite Recursion

However, we have not yet solved the problem of infinite recursion.
Say we create a scene full of objects with reflectivity 0.9.
We cast our ray beginning in the stem:[E]. It hits the scene at stem:[P].
Since the material is reflective, we create a new ray starting in stem:[P] and trace it.
We know that the resulting color will be multiplied by stem:[0.9].
The secondary ray hits the scene in stem:[P'].
Again we reflect the ray, but we know this color will only count for stem:[0.9 \times 0.9 = 0.81].
As the ray continuous bouncing around, the resulting's color effect will diminish at each step:

[stem]
++++
  1 \quad 0.9 \quad 0.81 \quad 0.729 \quad 0.6561 \quad 0.59049 \quad 0.531441 \quad 0.4782969 \quad \dots
++++

After a number of reflections we will arrive at a point where the next computed color will only matter for less than 1%.
We can easily stop tracing there without it visibly affecting the result.
The 1% threshold is chosen arbitrarily: if you prefer you can choose a higher or lower value.
Higher values mean tracing will end sooner and hence will reduce rendering times at the cost of losing details.

image::weight.png[align="center"]

To implement this, we need to pass along the "weight" to the ``trace`` function.
The weight indicates how much the result of the call will count in the final result.
``trace`` can then choose to immediately return black if this weight is below 1%.
This way, recursion is guaranteed to end, as long as with each recursive call, ``trace`` passes along an updated version of the weight which is lower than its own.

[#pseudo]
[source,language='python']
----
def trace(scene, ray, weight):
  if weight < THRESHOLD: // <1>
    return no_hit
  else:
    hit = scene.find_first_positive_hit(eye_ray)

    if hit:
      matprops = ...
      color = determine_color(scene, matprops, hit, eye_ray, weight)
    else:
      return no_hit


def determine_color(scene, matprops, hit, eye_ray, weight):
  result = black

  # Add ambient
  result += compute_ambient(...)

  # Add diffuse, specular
  result += process_light_sources(...)

  # Add reflection
  result += compute_reflection(..., weight)

  return result


def compute_reflection(scene, matprops, hit, eye_ray, weight):
  # Bounce off the object's surface
  reflected_ray = reflection of eye_ray at hit.position

  # Start the tracing algorithm all over again
  new_weight = weight * matprops.reflectivity
  return matprops.reflectivity * trace(scene, reflected_ray, new_weight) // <2>
----
1. `weight` represents how much effect it will have on the final result.
    Once the weight is below a certain threshold (say `0.01`), we can simply stop ray tracing.
2. `compute_reflection` recursively calls `trace` with an updated weight.

== Implementation

=== Introducing weight

We will first restructure the internals a bit to accomodate the `weight` parameter.
Once that is in place, we will be able to add reflection.

image::weight-adaptations.svg[align="center"]

==== determine_color

[TASK]
====
Create the necessary files to host `RayTracerV6`.
Define a class `RayTracerV6` that inherits from `RayTracerV5`, but is empty otherwise for now.
====

We need to add a `weight` parameter to both `trace` and `determine_color`.
Let's start with the latter.

[TASK]
====
Add a _protected_ method with signature

[source,language='c++']
----
Color RayTracerV6::determine_color(const Scene& scene,
                                   const MaterialProperties& material_properties,
                                   const Hit& hit,
                                   const Ray& eye_ray,
                                   double weight) const
----

Right now, it can simply call the base class's version of `determine_color`.
====

==== trace

Let's turn our attention to `trace`.
However, the supertype `RayTracerImplementation` demands that `trace` only has two parameters, namely `scene` and `eye_ray`.
Luckily, we can easily solve this by simply having two `trace` methods, one with and one without `weight`.


[TASK]
====
Override `trace(const Scene& scene, const math::Ray& ray) const`.
Have it do nothing more than call `trace(scene, ray, 1.0)`.
====

[TASK]
====
Add a _protected_ method with signature

[source,language='c++']
----
TraceResult trace(const Scene& scene,
                  const math::Ray& eye_ray,
                  double weight) const
----

Copy ``RayTracerV1::trace``'s body and adapt it so that it looks like <<#pseudo,the pseudocode shown above>>.
====

=== Reflection

We are now ready to incorporate reflection in our new ray tracer.

image::code-structure.svg[align="center"]

==== compute_reflection

[TASK]
====
Add a _protected_ method with signature

[source,language='c++']
----
Color compute_reflection(const Scene& scene,
                         const MaterialProperties& material_properties,
                         const Hit& hit,
                         const math::Ray& eye_ray,
                         double weight) const;
----

Implement its body as follows:

[source,language='python']
----
def compute_reflection(scene, matprops, hit, eye_ray, weight):
  reflectivity = matprops.reflectivity

  if reflectivity > 0:
    reflected_ray_origin = ...
    reflected_ray_direction = ...
    reflected_ray = Ray(reflected_ray_origin, reflected_ray_direction)
    reflected_color = trace(scene, reflected_ray, weight * reflectivity).color
    return reflectivity * reflected_color
  else:
    return black
----

[TIP]
=====
Rely on `Vector3D::reflect_by`.
You need a `Vector3D` to be reflected and a normal on the surface the ray is bouncing off of.
Both bits of information can be found in the parameters.
=====

[TIP]
=====
You may need to give `reflected_ray` a little nudge.
Remember <</extensions/ray-tracers/v4/explanations.asciidoc#approxerrs,this>>.
=====
====

==== determine_color revisited

[TASK]
====
`determine_color` is currently limited to a call to its base class's version.
We need it to also call `compute_reflection`.

[source,language='python']
----
def determine_color(...):
  result = black

  result += super.determine_color(...)
  result += compute_reflection(...)

  return result
----
====

=== Finishing Touches

[TASK]
====
Create a factory function `v6`.
====

[TASK]
====
Expose `v6` to the scripting language.
====

== Evaluation

TODO

* Nudging of ray