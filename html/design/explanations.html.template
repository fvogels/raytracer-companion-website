<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Design</title>
    <%= stylesheets('ucll', 'box') %>
    <%= scripts('jquery', 'underscore', 'box') %>
    <style>
      img.large {
        width: 60%;
      }

      table.centered {
        margin: 10px auto;
      }

      table th {
        width: 30%;
        text-align: left;
        background: #AAA;
        padding: 2px;
      }

      dt {
        font-weight: bold;
      }
    </style>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      
      function initialize()
      {
        Box.initialize();
      }

      $( initialize );    
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      <div class="center-vertically">Code Organization</div>
    </header>
    <div id="contents">
      <section>
        <h1>Design</h1>
        <p>
          We start off with a simplified overview of the ray tracer's architecture.
          Know that many designs are possible and we have to settle on a specific one.
          Sometimes, some choices might seem arbitrary to you; I will not pretend
          my design is "the right one". You are free to think about how you would
          change it, and maybe it can count as extension (albeit a risky one).
        </p>
        <p>
          The ray tracer is built out of many different modules.
          Each module is placed in its own subdirectory and its definitions
          reside in a separate namespace (akin to a Java package.)
          A module exposes only the bare minimum to the outside world.
          You can compare this to a class: a class has to hide as much
          as possible from its users, only making public what is truly necessary.
          The more implementation details it can hide, the better.
          You can apply the same principle to groups of classes:
          some classes are meant to be seen by people outside the module,
          but most should stay hidden as they are merely implementation detail.
        </p>
        <p>
          For example, the primitives module (we'll explain the name later)
          lets you create geometric shapes such as a sphere.
          Internally, this sphere is implemented as a class,
          but the module wants to hide this detail. Instead,
          only an abstract supertype <code>Primitive</code> is made public
          and a factory function which lets you create a sphere.
          So, outside of the primitives module,
          you are limited to writing <code>Primitive primitive = sphere();</code>
          You cannot directly create a Sphere-object (i.e. no <code>new Sphere()</code>),
          and you cannot access <code>Sphere</code>-specific methods.
        </p>
        <p>
          Here's an incomplete list of the modules:
        </p>
        <table class="centered">
          <thead>
            <tr>
              <th>Module name</th>
              <th>Files location</th>
              <th>Namespace</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Animation</td>
              <td>animation/</td>
              <td><code>animation</code></td>
            </tr>
            <tr>
              <td>Cameras</td>
              <td>cameras/</td>
              <td><code>raytracer::cameras</code></td>
            </tr>
            <tr>
              <td>Light</td>
              <td>lights/</td>
              <td><code>raytracer::lights</code></td>
            </tr>
            <tr>
              <td>Primitives</td>
              <td>primitives/</td>
              <td><code>raytracer::primitives</code></td>
            </tr>
            <tr>
              <td>Ray tracers</td>
              <td>raytracers/</td>
              <td><code>raytracer::raytracers</code></td>
            </tr>
            <tr>
              <td>Renderers</td>
              <td>renderers/</td>
              <td><code>raytracer::renderers</code></td>
            </tr>
            <tr>
              <td>Scripting</td>
              <td>scripting/</td>
              <td><code>raytracer::scripting</code></td>
            </tr>
          </tbody>
        </table>
        <p>
          Each of these modules will be explained in due time. For now, we will restrict
          ourselves to only what is absolutely necessary to have a basic understanding
          of the ray tracer, so as not to have you drown in details.
        </p>
        <p>
          A module mostly only exposes factory functions. So, if you want to know
          what kind of lights you can create, you can have the IDE enumerate
          the members of <code>raytracer::light</code>. For now,
          only <code>raytracer::light::omnidirectional</code> should be available to you,
          which creates a point light that shines equally in all directions.
        </p>
      </section>

      <section>
        <h1>Classes</h1>
        <p>
          A ray tracer can be seen as software that allows you to build a virtual world
          and take a picture inside it. We introduce two important terms (these same words
          also appear the ray tracer's design):
        </p>
        <dl>
          <dt>Scene</dt>
          <dd>
            The scene defines the virtual world and the camera we use to take a picture of it.
          </dd>
          <dt>Renderer</dt>
          <dd>
            The renderer is the "engine" that actually performs the rendering. It takes a scene
            and outputs an image.
          </dd>
        </dl>
        <p>
          For example, consider the picture below:
          <%= raytrace 'scene' %>
          This rather boring scene consists of 2 reflective spheres, one red and one blue.
          It also contains a light that shines from the upper right (notice the bright spots on both spheres.)
          Lastly, the scene also defines where the camera is located, i.e. right before the two spheres.
        </p>

        <section>
          <h2>The Scene</h2>
          <p>
            We define what a scene is more formally. A scene has three components:
          </p>
          <dl>
            <dt>Root</dt>
            <dd>
              The root defines all the objects in the scene.
              It is admittedly a somewhat strange name, but it will make more sense later.
            </dd>
            <dt>
              Light Sources
            </dt>
            <dd>
              A list of all light sources.
            </dd>
            <dt>
              Camera
            </dt>
            <dd>
              The location and orientation of the camera.
            </dd>
          </dl>
          <p>
            Applying this to the example above gives
          </p>
          <ul>
            <li>
              The root is what defines the location, size and color of both spheres.
            </li>
            <li>
              The light sources list consists of just one light: a white light located to the upper right.
            </li>
            <li>
              The camera is placed in front of the two spheres and looks straight at them.
            </li>
          </ul>
        </section>

        <section>
          <h2>The Renderer</h2>
          <p>
            The renderer is a bit more technical.
            First of all, there are different types of renderers, each of which
            will produce a different rendition of the scene.
            The picture above was produced by the standard renderer,
            which performs no fancy tricks. Another kind of renderer
            could render the same scene so as to
            <%= link( "../extensions/renderers/cartoon", 'look more cartoony') %>.
            <!-- TODO More links -->
          </p>
          <p>
            Different types of renderers have different components, so for now we will
            pretend only the standard renderer exists.
            Go find the declaration for the factory function in the code.
            It is located in de renderers module, in the file <code>standard-renderer.h</code>.
            As you see, it requires the following inputs:
          </p>
          <dl>
            <dt>Image size</dt>
            <dd>The size of the output image. The example above has size 500&times;300.</dd>
            <dt>Sampler</dt>
            <dd>
              This is a more advanced feature which will be explained later in greater detail.
              Suffice it to say that it determines image quality. To create a sampler,
              you can look what factory functions are available in the <code>raytracer::samplers</code> namespace.
            </dd>
            <dt>Ray tracer</dt>
            <dd>
              Which ray tracer to be used. This is the actual work horse: it is the ray
              tracer that performs the heavy duty work of determining colors, shadows, reflections, etc.
              The renderer basically just asks the ray tracer to determine what color light enters from a certain direction, and
              the renderer will then paint the corresponding pixel in that color. We will discuss ray tracers in detail shortly.
            </dd>
            <dt>Looper</dt>
            <dd>
              Like samplers, this is more advanced stuff. In essence, it's an object that you can use for looping.
              It's a <code>for-loop</code>, but in the form of an object. For now, you only have a basic looper, which will just loop.
              A <%= link('../extensions/performance/multithreaded-looper', 'more advanced one') %> will instead
              be multithreaded, which gives a serious performance boost.
            </dd>
          </dl>
          <p>
            Once you've created a renderer, you can feed it a scene using the <code>render</code> method
            (see renderers/renderer.h), and it will give you a nice bitmap in return.
          </p>
          <%= tex_image 'renderer' %>
        </section>

        <section>
          <h2>The Ray Tracer</h2>
          <p>
            As mentioned before, the ray tracer is where the actual works gets done.
            It is responsible for following light rays around the scene and determining
            the color of each object, taking into account lights, materials, reflection, refraction, etc.
            We won't develop all these features in one go but instead incrementally.
          </p>
          <p>
            Here's a list of the ray tracer extensions. Each is built upon the previous one.
          </p>
          <ul>
            <li><%= link('../extensions/ray-tracers/v1', 'v1') %>: everything is lit the same</li>
            <li><%= link('../extensions/ray-tracers/v2', 'v2') %>: light position is taken into account</li>
            <li><%= link('../extensions/ray-tracers/v3', 'v3') %>: specular highlights, i.e. the shiny highlights giving a more metallic look</li>
            <li><%= link('../extensions/ray-tracers/v4', 'v4') %>: shadows</li>
            <li><%= link('../extensions/ray-tracers/v5', 'v5') %>: reflection</li>
            <li><%= link('../extensions/ray-tracers/v6', 'v6') %>: refraction</li>
          </ul>
          <p>
            Go take a look in raytracers/ray-tracer.h and you'll find that ray tracers offers only a single method: <code>trace</code>.
            This method takes two parameters: a scene and a ray. The ray tracer then traces the ray, i.e. computes
            what object in the scene it hits and finds out what color the object has at that point.
            If the object is transparent, the ray tracer will (if it supports refraction at least) compute
            how the ray passes through the object. If the object is reflective, the ray tracer must
            compute in which direction the ray gets reflected, and so on.
          </p>
        </section>
      </section>

      <section>
        <h2>Primitives</h2>
        <p>
          In order to better understand how the ray tracer works, we must discuss in detail how a scene is modelled.
          The light and camera components of a scene are pretty
          straightforward: they're just subtypes of <code>LightSource</code> and <code>Camera</code> respectively,
          and different types of lights/cameras are implemented as different subclasses.
        </p>
        <p>
          The root part of the scene, however, is less straightforward, but the structure should not be unfamiliar to you.
          First, do remember what the root represents: the actual objects the scene is built out of.
          The implementation of the root follows the <a href="https://en.wikipedia.org/wiki/Composite_pattern">Composite design pattern</a>,
          which is the same design typically used by GUI libraries, which you have worked with in the past.
        </p>

        <section>
          <h3>Analogy: Design of GUI Libraries</h3>
          <p>
            How are GUIs represented using object-oriented design? Simple: by composition.
          </p>
          <p>
            First, you get access to basic building blocks: buttons, text boxes, check boxes, labels, etc.
            Next, you get a means of putting these together into larger whole.
            For example, using WPF terminology, a <code>StackPanel</code> allows
            you to put GUI controls next to each other, either horizontally or vertically.
            A <code>Grid</code> allows you to layout controls in a grid-like fashion.
            You can see these panels as "operations" on GUI controls, a bit like the "addition" of two controls
            yielding a new, bigger control.
          </p>
          <p>
            Another example of such an operation is the <code>Border</code>: this allows you to take a control
            and have a border drawn around it. A <code>ScrollViewer</code> can be used when a control is too
            big to fit on the screen and you need scrollbars. A <code>ViewBox</code> is another operation
            which can scale controls.
          </p>
          <p>
            The most important aspect of the Composite design pattern is the fact that it is <em>recursive</em>.
            In other words, if you apply an operation (be it a Panel, a ViewBox, a Border, or whatever) on a control, the result
            is once again a control, on which you can then proceed to apply the same operations again. For example, you can have a <code>Button</code>,
            you can apply the <code>Border</code> operation on it, and then again, and then once more, and you'll have a button with three borders.
            This three-bordered button can then be put inside a panel, which can have borders of its own, etc.
            The fact that it is recursive, i.e. that every operation on controls yields a new control, allows you to build
            arbitrarily large GUIs.
          </p>
        </section>

        <section>
          <h3>Primitives: Basic Building Blocks</h3>
          <p>
            So, how do we apply the same principles on scenes? Let's first try to find out what the basic building blocks are,
            and then which operations can be performed on them.
          </p>
          <p>
            The basic building blocks are geometric shapes. Games, for example, use only one such shape as building, namely the triangle.
            Technically, this is enough to build even the most complex of shapes: you just have to make the triangles very tiny
            and have enough of them. While it may seem simpler to only have to implement one shape, you have to remember
            that you'll still have to find a way to produce all the right triangles so as to create, say, a sphere.
            You're just shifting the complexity elsewhere.
          </p>
          <p>
            In other words, it is easier to implement both <code>Triangle</code> and <code>Sphere</code> than to just
            implement <code>Triangle</code> and build a <code>Sphere</code> out of it. Working with a single sphere
            is also much more efficient than to have to work with thousands of tiny triangles.
          </p>
          <p>
            So, what will our basic shapes be? Well, any shape that have a simple enough mathematical formula. Examples are:
          </p>
          <ul>
            <li>Spheres</li>
            <li><%= link('../extensions/primitives/plane', 'Planes') %></li>              
            <li><%= link('../extensions/primitives/cylinder', 'Cylinders') %></li>
            <li><%= link('../extensions/primitives/cone', 'Cones') %></li>
            <li><%= link('../extensions/primitives/disk', 'Disks') %></li>
            <li><%= link('../extensions/primitives/triangle', 'Triangles') %> (you weren't planning on building triangles out of many tiny spheres, were you?)</li>
          </ul>
          <p>
            These basic shapes are so primitive that (in our design) you cannot even change their size or position in space (except for triangles.)
            For example, you can only create spheres with radius 1 that are centered at $(0, 0, 0)$.
          </p>
        </section>

        <section>
          <h3>Transformations</h3>
          <p>
            This brings us to the operations we can apply on these primitives. There are actually many types of operations available,
            some more abstract than others. The most straightforward operations are transformations:
          </p>
          <ul>
            <li>Translation</li>
            <li><%= link('../extensions/primitives/scaling', 'Scaling') %></li>
            <li><%= link('../extensions/primitives/rotation', 'Rotation') %></li>
          </ul>
          <p>
            So, even if spheres themselves only come in size 1, you can use scaling to make them as big or as small as you want.
            This approach has the advantage that it makes the implementation much simpler. It is certainly possible to
            create a <code>Sphere</code> class whose constructor takes a center and radius parameter, but the mathematical formula
            behind it will be more complex.
          </p>
          <p>
            For example, take the cylinder primitive. For an arbitrary cylinder with radius $R$ whose axis has direction $\vec N$ and goes through some point $P$,
            the formula is
            \[
              \left(O + \vec\Delta \cdot t - \frac{O + \vec\Delta \cdot t - P}{\vec N \cdot \vec N} \cdot \vec N\right) \cdot \left(O + \vec\Delta \cdot t - \frac{O + \vec\Delta \cdot t - P}{\vec N \cdot \vec N} \cdot \vec N\right) = R^2
            \]
            This is quite an intimidating formula. If, however, we choose to only support vertical cylinders (i.e. $\vec N = (0, 1, 0)$ and $P = (0,0,0)$) with radius 1 ($R = 1$), this formula can be simplified considerably.
          </p>
          <p>
            So, either we write $N$ smart shape classes that are difficult to implement,
            or $N + 3$ "dumb" classes ($N$ shape + 3 transformation classes) that are much easier to implement.
            Our design will follow the latter path.
          </p>
        </section>

        <section>
          <h3>Combining Shapes</h3>
          <p>
            We have discussed the basic building blocks (sphere, cylinder, cone, &hellip;) and
            transformations (translating, scaling, rotating). This still merely allows us to
            create scenes consisting of a single shape, but hey, look at the bright side,
            it be as big as you want.
          </p>
          <p>
            In order to allow for scenes built out of multiple shapes, we need
            some "grouping" operation, like panels in GUI libraries. For this,
            we provide <a href="https://en.wikipedia.org/wiki/Constructive_solid_geometry">Constructive Solid Geometry</a> operations:
          </p>
          <ul>
            <li>
              <%= link('../extensions/primitives/union', 'Unions') %>
            </li>
          </ul>
        </section>
        
      </section>
    </div>
  </body>
</html>
