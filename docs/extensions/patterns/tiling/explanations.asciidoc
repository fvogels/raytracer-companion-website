// order 3
= Tiling

[overview]
----
difficulty 3
requires ray-tracers/v1
requires patterns/basics
requires patterns/lambda
----

As mentioned before, a pattern can be seen as a black and white image.
But not just any black and white image, but rather an infinitely large one.
For any position stem:[(x, y)] or stem:[(x, y, z)], the pattern must decide whether that spot is black or white.

In order to fill up this infinite space, we generally rely on repetition: one simple patterns gets copied an infinite number of times.
In this extension, you will have to create the "for loop" of patterns: the `tiling` operation takes a "child pattern", a width and a height and will then copy this ad infinitum.

[NOTE,caption='example']
====
We start off we with simple pattern:

image::single.png[align="center",width="25%"]

Tiling will lead to this:

image::tiling.png[align="center",width="25%"]
====

== Implementation

[TASK]
====
Create files `patterns/pattern-tiling.cpp` and `patterns/pattern-tiling.h`.

Also add the header file to `patterns/patterns.h`.
====

=== tiling

Given a point stem:[(x, y)], you need to "remap" it to stem:[[0,0\] \times [w, h\]].
This remapped point can then be fed to the child pattern.

image::remapping.png[align="center",width="50%"]

[TASK]
====
Implement tiling as a function

[source,language='c++']
----
Pattern2D tiling(Pattern2D pattern, double width, double height)
----

Rely on `make_pattern` from the <</extensions/patterns/lambda/explanations#,lambda pattern extension>>.

[TIP]
=====
The remapping can be done by an operation known to you that does this in a single step, i.e., don't use loops.
=====
====

[IMPORTANT]
====
You might have some trouble to get the area around stem:[(0,0)] right.
Say you are copying this pattern:

image::checker.png[align="center",width="10%"]

[.center,options="header",cols="^,^"]
|===
| Correct | Wrong
a| image::right.png[]
a| image::wrong.png[]
|===
====

=== tiling_x, tiling_y

`tiling` takes a rectangular pattern and copies it both horizontally and vertically.
What if we already have an infinitely wide pattern and only need to copy it vertically, or vice versa?

[TASK]
====
Implement horizontal and vertical tiling as two functions

[source,language='c++']
----
Pattern2D tiling_x(Pattern2D pattern, double width)
Pattern2D tiling_y(Pattern2D pattern, double height)
----

Rely on `make_pattern` from the <</extensions/patterns/lambda/explanations#,lambda pattern extension>>.
====

=== tiling in 3D

The same trick can be applied in 3D.
We get a "pattern box" which is copied along all three axes.

[TASK]
====
Implement 3D tiling as

[source,language='c++']
----
Pattern3D tiling(Pattern3D pattern,
                 double x_size,
                 double y_size,
                 double z_size)
----

Rely on `make_pattern` from the <</extensions/patterns/lambda/explanations#,lambda pattern extension>>.
====

=== Finishing Touches

[TASK]
====
Add bindings to expose this new functionality to the scripting language.
====

== Evaluation

TODO

[TASK]
====
Use `tiling_y` to create a pattern `lines(thickness, spacing)` for horizontal lines.

* `thickness` represents the thickness of each line.
* `spacing` represents the space between lines.

image::lines.png[align="center",width="25%"]

Rely on `xsplit` or `ysplit` from <</extensions/patterns/lambda/explanations#,

preview::hlines[]
====

* Pattern should not be mirrored around stem:[(0, 0)].
* Efficiency: show code to make sure no loops were utilized
* Show how `lines` is defined in terms of one of the `split` extensions and `tiling`.
