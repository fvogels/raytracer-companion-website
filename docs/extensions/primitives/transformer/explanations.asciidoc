= Transformations

[overview]
----
difficulty 2
reading design/transformations
reading math/transformations/3d/rotation
reading math/transformations/3d/scaling
----

preview::preview[]

== Introduction

A ray tracer can support many shapes, such as spheres, cylinders, cones, planes, triangles, boxes and so on.
When building a scene, we want to be able to place these shapes anywhere we want, resize them and rotate them on a whim.

While it would be possible to parameterize all these primitives so that each of them can have a chosen position, size and rotation, this would make their implementation more complex.
Instead, we choose another approach: each primitive should only be implemented in its most simple form.
For example, a sphere should be centered at stem:[(0,0,0)] and have radius 1, as these parameters maximally simplify the formulae involved.

So what if we want a bigger sphere?
Instead of trying to make the sphere bigger, we make the camera smaller.
The nice part about this approach is that we can apply the same trick on all primitives.
Similarly, if we want to move the sphere up, we can simply move the camera down instead.
Rotation can be handled the same way.

== Translation

Translation consists of moving a shape to a different position.
Luckily for you, this has already been implemented.
The code can act as a guide for you to implement the two other transformations (rotation and scaling.)

== Rotation

We will offer rotation as three separate functions, one for each axis:

* `rotate_around_x(angle, child)`
* `rotate_around_y(angle, child)`
* `rotate_around_z(angle, child)`

You might wonder why we don't simply use a single `rotate(x_angle, y_angle, z_angle, child)`.
We could, but the problem is that the order of rotation matters:
rotating around X, then around Y yields different results than rotating around Y, then around X.
Therefore, offering three separate functions would lead to less confusion.

=== Transformation3D

First, we need to define the rotation matrices and their inverse.
We bundle each rotation matrix and its corresponding inverse in a `Transformation3D` object.

[TASK]
====
Open ``math/transformation3d.cpp``.
Use ``math::transformations::translation`` as a guide for this task.

In ``math/transformation3d.cpp``, add function definitions for

* ``math::transformations::rotate_x(Angle angle)``
* ``math::transformations::rotate_y(Angle angle)``
* ``math::transformations::rotate_z(Angle angle)``

Expose them to the rest of the application by adding a declaration in the corresponding header.
====

=== Rotation Primitive

Now we want rotation to exist as a member of the `Primitive` hierarchy.

[TASK]
====
Open ``primitives/transformer-primitive.cpp``.
You can use the given implementation of `raytracer::primitives::translate` as a guide.

To the same file, add three functions with signatures

* `Primitive raytracer::primitives::rotate_around_x(math::Angle angle, Primitive child)`
* `Primitive raytracer::primitives::rotate_around_y(math::Angle angle, Primitive child)`
* `Primitive raytracer::primitives::rotate_around_z(math::Angle angle, Primitive child)`

Add declarations to the appropriate header file so that these functions are accessible to the other compilation units.
====

=== Bindings

[TASK]
====
Add the necessary bindings so to make rotation available in scripts.
====

== Scaling

=== Transformation3D

First, define the translation matrices and their inverse and bundle them in a `Transformation3D` object.

[TASK]
====
Open ``math/transformation3d.cpp``.
Use ``math::transformations::translation`` as a guide for this task.

In ``math/transformation3d.cpp``, add a function definition `math::transformations::scale(double sx, double sy, double sz)`.

Expose the function to the rest of the application by adding a declaration in the corresponding header.
====

=== Rotation Primitive

Now we want scaling to exist as a member of the `Primitive` hierarchy.

[TASK]
====
Open ``primitives/transformer-primitive.cpp``.
You can use the given implementation of `raytracer::primitives::translate` as a guide.

To the same file, add a function with signature `Primitive raytracer::primitives::scale(double sx, double sy, double sz, Primitive child)`
Add declarations to the appropriate header file so that these functions are accessible to the other compilation units.
====

=== Bindings

[TASK]
====
Add the necessary bindings so to make scaling available in scripts.
====
