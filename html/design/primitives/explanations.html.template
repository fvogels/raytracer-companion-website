<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Design</title>
    <%= stylesheets('ucll', 'box') %>
    <%= scripts('jquery', 'jquery-ui', 'underscore', 'box', 'ace/ace', 'source-editor') %>
    <style>
      img.large {
        width: 60%;
      }

      table.centered {
        margin: 10px auto;
      }

      table th {
        width: 30%;
        text-align: left;
        background: #AAA;
        padding: 2px;
      }

      dt {
        font-weight: bold;
      }
    </style>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      
      function initialize()
      {
        Box.initialize();
      }

      $( initialize );    
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      <div class="center-vertically">Design</div>
    </header>
    <div id="contents">
      <section>
        <h1>Disclaimer</h1>
        <p>
          This page delves into the technical details of how primitives are designed. Since the final design
          has some complexity to it, we will build up to it and not tell you the whole truth right away.
          Instead, we start off with a simple design that we will modify as we go on.
        </p>
      </section>
      
      <section>
        <h1>The Composite Design Pattern</h1>
        <p>
          The <code>Primitive</code> hierarchy relies heavily on the
          <a href="https://en.wikipedia.org/wiki/Composite_pattern">Composite design pattern</a>.
          For those unfamiliar with the concept, we will first explore a different class hierarchy
          that you should already have experience with.
        </p>

        <section>
          <h2>Examples</h2>
          <section>
            <h3>Design of GUI Libraries</h3>
            <p>
              How are GUIs represented using object-oriented design? Simple: by composition.
            </p>
            <p>
              First, you get access to basic building blocks: buttons, text boxes, check boxes, labels, etc.
              Next, you get a means of putting these together into larger whole.
              For example, using WPF terminology, a <code>StackPanel</code> allows
              you to put GUI controls next to each other, either horizontally or vertically.
              A <code>Grid</code> allows you to layout controls in a grid-like fashion.
              You can see these panels as "operations" on GUI controls, a bit like the "addition" of two controls
              yielding a new, bigger control.
            </p>
            <p>
              There are many such "operations" available:
            </p>
            <ul>
              <li>
                The <code>Border</code> control has the very limited task of,
                given a child control, to draw a border around it.
              </li>
              <li>
                A <code>ScrollViewer</code> can be used on a large control so as to make
                it possible to choose which part of it should be visible on screen.
              </li>
              <li>
                A <code>ViewBox</code> takes a child control and scales it.
              </li>
            </ul>
            <p>
              The most important aspect of the Composite design pattern is its <em>recursiveness</em>.
              In other words, if you apply an operation (be it a Panel, a ViewBox, a Border, or whatever) on a control, the result
              is once again a control, on which you can then proceed to apply the same operations again. For example, you can have a <code>Button</code>,
              you can apply the <code>Border</code> operation on it, and then again, and then once more, and you'll have a button with three borders.
              This three-bordered button can then be put inside a panel, which can be put inside a <code>ViewBox</code>, etc.
              This recursiveness, i.e. that every operation on controls yields a new control, allows you to build
              arbitrarily large GUIs.
            </p>
          </section>

          <section>
            <h3>Classes and Objects</h3>
            <p>
              Classes and objects follow the same principle. Here, the basic building blocks are the primitive types:
              <code>int</code>, <code>char</code>, <code>bool</code>, &hellip; Classes allow you to group these together
              into new types, and these new types can then be used in the construction of other types, and so on.
            </p>
            <p>
              Imagine what would happen if this were not the case: say a class can only contain primitive types.
              This would be quite restrictive, making large programs much more difficult to create.
            </p>
          </section>
        </section>

        <section>
          <h2>Primitives: Basic Building Blocks</h2>
          <p>
            So, how do we apply the same principles on primitives? Let's first try to find out what the basic building blocks are,
            and then which operations can be performed on them.
          </p>
          <p>
            The basic building blocks are geometric shapes. Games, for example, use only one such shape as building, namely the triangle.
            Technically, this is enough to build even the <%= link('extensions/primitives/mesh', 'most complex of shapes') %>: you just have to make the triangles very tiny
            and have enough of them. While it may seem simpler to only have to implement one shape, you have to remember
            that you'll still have to find a way to produce all the right triangles, so you're just shifting the complexity elsewhere.
          </p>
          <p>
            In other words, it is easier to implement both <code>Triangle</code> and <code>Sphere</code> than to just
            implement <code>Triangle</code> and build a <code>Sphere</code> out of it. Working with a single sphere
            is also much more efficient than to have to work with thousands of tiny triangles.
          </p>
          <p>
            So, what will our basic shapes be? Well, any shape that have a simple enough mathematical formula. Examples are:
          </p>
          <ul>
            <li>Spheres</li>
            <li><%= link('extensions/primitives/plane', 'Planes') %></li>              
            <li><%= link('extensions/primitives/cylinder', 'Cylinders') %></li>
            <li><%= link('extensions/primitives/cone', 'Cones') %></li>
            <li><%= link('extensions/primitives/triangle', 'Triangles') %> (you weren't planning on building triangles out of many tiny spheres, were you?)</li>
            <li><%= link('extensions/primitives/disk', 'Disks') %></li>
            <li><%= link('extensions/primitives/square', 'Squares') %></li>
            <li><%= link('extensions/primitives/cube', 'Cubes') %></li>
          </ul>
          <p>
            These basic shapes are so primitive that (in our design) you cannot even change their size or position in space (except for triangles.)
            For example, you can only create spheres with radius 1 that are centered at $(0, 0, 0)$.
          </p>
        </section>

        <section>
          <h3>Transformations</h3>
          <p>
            This brings us to the operations we can apply on these primitives. There are actually many types of operations available,
            some more abstract than others. The most straightforward operations are transformations:
          </p>
          <ul>
            <li>Translation</li>
            <li><%= link('extensions/primitives/scaling', 'Scaling') %></li>
            <li><%= link('extensions/primitives/rotation', 'Rotation') %></li>
          </ul>
          <p>
            So, even though spheres themselves only come in size 1, you can use scaling to make them as big or as small as you want.
            This approach has the advantage that it makes the implementation much simpler. It is certainly possible to
            create a <code>Sphere</code> class whose constructor takes a center and radius parameter, but the mathematical formula
            behind it will be more complex.
          </p>
          <p>
            For example, take the cylinder primitive. For an arbitrary cylinder with radius $R$ whose axis has direction $\vec N$ and goes through some point $P$,
            the formula is
            \[
            \left(O + \vec\Delta \cdot t - \frac{O + \vec\Delta \cdot t - P}{\vec N \cdot \vec N} \cdot \vec N\right) \cdot \left(O + \vec\Delta \cdot t - \frac{O + \vec\Delta \cdot t - P}{\vec N \cdot \vec N} \cdot \vec N\right) = R^2
            \]
            This is quite an intimidating formula. If, however, we choose to only support vertical cylinders (i.e. $\vec N = (0, 1, 0)$ and $P = (0,0,0)$) with radius 1 ($R = 1$), this formula can be simplified considerably.
          </p>
          <p>
            So, although this approach requires us to write more classes, they are much easier to write since they
            each have very limited responsibilities. Each class can also be tested separately, further simplifying our job.
          </p>
        </section>

        <section>
          <h3>Combining Shapes</h3>
          <p>
            We have discussed the basic building blocks (sphere, cylinder, cone, &hellip;) and
            transformations (translating, scaling, rotating). This merely allows us to
            create scenes consisting of a single shape, but hey, look at the bright side,
            it can be as big as you want.
          </p>
          <p>
            In order to allow for scenes built out of more than one shape, we need
            some "grouping" operation, like panels in GUI libraries. For this,
            we provide <a href="https://en.wikipedia.org/wiki/Constructive_solid_geometry">Constructive Solid Geometry</a> operations.
          </p>
          <ul>
            <li>
              <%= link('extensions/primitives/union', 'Unions') %> allows you to have multiple primitives in the scene, i.e.
              the union of two spheres is&hellip; two spheres.
            </li>
            <li>
              <%= link('extensions/primitives/intersection', 'Intersections') %>
            </li>
            <li>
              <%= link('extensions/primitives/difference', 'Difference') %>
            </li>
          </ul>
          <p>
            These operations together with transformations allow you to craft any shape you want.
          </p>
        </section>

        <section>
          <h3>Decorators and Materials</h3>
          <p>
            Another important operation on primitives is the <em>decorator</em> which assigns a <em>material</em> to a primitive.
            By default, a basic shape has no material assigned to it, meaning it has no color (not even black),
            no reflectance properties, etc. It is therefore an error to try to render an undecorated shape.
          </p>
          <p>
            We can define any kind of materials. Examples are
          </p>
          <ul>
            <li>
              <%= link('extensions/materials/marble', 'Marble') %>
            </li>
            <li>
              <%= link('extensions/materials/dalmatian', 'Dalmation spots') %>
            </li>
            <li>
              <%= link('extensions/materials/texture', 'Textures') %>
            </li>
          </ul>
        </section>

        <section>
          <h3>Example</h3>
          <p>
            Consider the scene shown below.
          </p>
          <%= raytrace_movie 'example' %>
          <p>
            It is described by the following hierarchy:
          </p>
          <%= tex_image 'example-hierarchy' %>
          <p>
            In the animation above, you can see two separate objects:
            a plane with a grid drawn on it and a green lens. The union at the
            top of the hierarchy has as sole purpose of grouping the plane and lens together.
            Both the plane and the lens need to be decorated; as you can see,
            there's indeed a separate decorator for both. We omitted the details of the material.
            The plane material is responsible for the grid pattern, while the lens's material
            specifies that the lens is green and refracts light.
          </p>
          <p>
            The lens is placed above the plane. We can achieve this in multiple ways:
            we could lower the plane or raise the lens. We decided to move the plane downwards.
          </p>
          <p>
            Lastly, we need to create the lens. The lens is not a basic shape, but it can be
            created by intersecting two spheres: we create two spheres, move one a bit to the left,
            the other to the right, and we only keep their intersection.
          </p>
          <p>
            The following C++ code performs all necessary steps to create this scene. Take some time to see how it works.
          </p>
          <%= source 'example.cpp' %>
          <p>
            The ray tracer is also equipped with a <a href="http://chaiscript.com/">scripting language</a>.
            Using this language is much more practical: if you were to create each scene in C++,
            you'd have both to deal with C++'s complexity and long compilation times.
            Using the scripting language avoids all of C++'s pitfalls, plus it requires no compilation.
            In this scripting language, the same scene would look as follows:
          </p>
          <%= source 'example.chai' %>
        </section>
      </section>

      <section>
        <h1>Classes</h1>
        <p>
          We now focus on how primitives are implemented. First, a warning: we will not immediately be telling you the
          whole truth, but instead explain in steps how the design has evolved. Hopefully, this will result in you have a better understanding
          of the final design.
        </p>
        <p>
          We've been talking incessentantly about primitives that it should come as no surprise
          that there is a superclass representing this concept. So, let's start with an abstract superclass <code>Primitive</code>.
          Methods are not important for now, so there's nothing else to say for the moment about <code>Primitive</code> itself.
        </p>
        <p>
          The basic shapes such as sphere, plane, cone, and cylinder are as you would expect subclasses of <code>Primitive</code>.
        </p>
        <%= tex_image('shape-hierarchy', html_class:'centered', style: 'width: 30%;') %>
        <p>
          Things get more interesting with transformers. A transformer is something that takes a <code>Primitive</code>
          and is in itself also a <code>Primitive</code>. Compare this to mathematical operators: the addition
          takes two values, and is in itself also a value.
        </p>
        <%= tex_image('transformation-hierarchy', html_class:'centered', style: 'width: 50%;') %>
        <p>
          Notice the following details:
        </p>
        <ul>
          <li>
            Each <code>Transformer</code> object keeps a link to a <code>Primitive</code>.
          </li>
          <li>
            Each <code>Transformer</code> object is itself a <code>Primitive</code>. Herein lies the power of the composite design pattern lies.
          </li>
          <li>
            <code>Rotation</code> is split up into three specialized rotations: around the X-axis, around the Y-axis and around the Z-axis.
          </li>
        </ul>
        <p>
          For example, creating a 2-radius sphere centered at (1, 2, 3) requires the creation of three objects:
          a <code>Sphere</code>, a <code>Translation</code> and a <code>Scaling</code> object. C++ code creating
          these objects would look like this:
        </p>
        <%= source 'sphere-example.cpp' %>
        <p>
          Because each transformer is in itself a primitive, we can keep applying multiple transformations in row. Without this recursiveness,
          we could not have translated the scaling.
        </p>
        <p>
          Remember though that these classes belong the the <code>primitives</code> module, so the classes are private to that module.
          The only functionality the module exposes is the ability to create objects of these classes:
        </p>
        <%= source 'primitives-api.cpp' %>
        <p>
          Now, we've always told you that working with pointers directly is generally a bad idea, on account of them
          being so brittle. It'd be much better were we to use the more robust <code>std::shared_ptr</code>, so
          the public interface of the <code>primitives</code> module looks like this:
        </p>
        <%= source 'primitives-api-shared-ptrs.cpp' %>
        <p>
          While this is technically a better solution, it is also excessively verbose.
          Luckily, C++ allows for type aliases. Let's introduce an alias for <code>std::shared_ptr&lt;Primitive&gt;</code>:
        </p>
        <%= source 'primitives-api-alias.cpp' %>
        <p>
          Now, this is rather silly. <code>Primitive</code> is meant to be hidden, while <code>PPrimitive</code> is exposed.
          Why give the clumsy name to the type that we'll actually have to use?
        </p>
        <p>
          It would make more sense to give the private type an "ugly" name and the public type a user-friendly one:
        </p>
        <%= source 'primitives-api-wrappers.cpp' %>
        <p>
          Now, <code>Primitive</code> is the public type, while <code>PrimitiveImplementation</code> is the private one.
          This is the naming used in the RayTracer's design. There is one small difference though: instead
          of <code>Primitive</code> being an alias for <code>std::shared_ptr&lt;PrimitiveImplementation&gt;</code>,
          it is a small <%= link 'design/wrappers', 'wrapper class' %>, but this makes almost no difference.
        </p>
        <section>
          <h2>The Truth About Transformers</h2>
          <p>
            We warned you we wouldn't be completely honest with you, but now it's time for the truth.
            In the actual RayTracer's design, there is no transformer class hierarchy, but just one transformer class
            which supports all transformations. This seemingly violates the single responsibility principle,
            but rest assured, it does not.
          </p>
          <p>
            What happened is that we traded in inheritance for composition. Compare it to creating a <code>Person</code> class,
            where each <code>Person</code> has an age. While it is certainly possible to have a <code>Person</code> superclass
            with subclasses <code>PersonAged1</code>, <code>PersonAged2</code>, <code>PersonAged3</code>, etc. you would
            probably prefer to just use a single <code>Person</code> class with a member variable <code>age</code>.
          </p>
          <p>
            The same principle applies to transformers, but instead of having an age, transformers have <em>transformation matrices</em>.
            For reasons that will become apparent later, a transformer needs to be able to transform both ways. For example,
            a transformer that doubles primitives in size also needs to know how to halve them back to their original size.
            So, the transformer needs both a transformation matrix and its inverse. We group these two together in
            a separate class called a <em>transformation</em>.
          </p>
          <p>
            This all may seem quite confusing, so let's give a quick overview of the different concepts:
          </p>
          <ul>
            <li>
              A <em>transformation matrix</em> is a matrix representing a transformation. Internally, it is nothing but a bunch of numbers.
              Transformation matrices are accessible through <code>math/transformation-matrices.h</code>.
            </li>
            <li>
              A <em>transformation</em> groups two transformation matrices together, one representing the "forward" transformation,
              the other the inverse. For example, a scaling transformation groups together these matrices:
              \[
                M =
                \begin{bmatrix}
                  2 & 0 & 0 & 0 \\
                  0 & 2 & 0 & 0 \\
                  0 & 0 & 2 & 0 \\
                  0 & 0 & 0 & 1 \\
                \end{bmatrix}
                \qquad
                M^{-1} =
                \begin{bmatrix}
                  1/2 & 0 & 0 & 0 \\
                  0 & 1/2 & 0 & 0 \\
                  0 & 0 & 1/2 & 0 \\
                  0 & 0 & 0 & 1 \\
                \end{bmatrix}
              \]
              Transformations are declared in <code>math/transformation3d.h</code>.
            </li>
            <li>
              A <em>transformer</em> takes a transformation and a primitive and applies the former on the latter.
              You can find its declaration in <code>primitives/transformer-primitive</code>.
            </li>
          </ul>
          <%= tex_image 'scale-objects' %>
        </section>
      </section>
      
      <section>
        <h1>Functionality</h1>
        <p>
          We've discussed what the primitive class hierarchy looks like, but we ignored what member functions were
          necessary. In other words, given that <code>PrimitiveImplementation</code> is the superclass of all
          primitives, what are its member functions?
        </p>
        <p>
          You'll be happy to learn that for each primitive, you only need to implement a grand total of two member functions:
        </p>
        <ul>
          <li>
            <code>std::vector&lt;std::shared_ptr&lt;Hit&gt;&gt; find_all_hits(const Ray&amp; ray) const</code>
            computes where the <%= link 'glossary/math/ray', 'ray' %> hits the primitive.
          </li>
          <li>
            <code>Box bounding_box() const</code> returns a 3D box that should be barely large enough to contain the whole primitive.
          </li>
        </ul>
        <p>
          A third member function, <code>find_first_positive_hit</code>, can optionally be overridden for optimization purposes.
          If you do not override it, it will fall back on its default implementation, i.e. calling <code>find_all_hits</code>
          and returning the first positive hit. It should be obvious that writing a separate algorithm
          that specializes in only finding the first positive hit should work much faster than one that computes all hits.
        </p>
        <section>
          <h2>find_all_hits</h2>
          <p>
            Finding all hits between a ray and a primitive is the hardest part of writing the RayTracer, as it involves
            a bit of math. Fortunately for you, you will not have to derive the necessary formulae; we will just give them to you.
            It will be up to you to translate a mathematical expression into C++ code.
          </p>
          <section>
            <h3>find_all_hits for spheres</h3>
            <p>
              As mentioned above, <code>find_all_hits</code>'s job is to determine where a <%= link 'glossary/math/ray', 'ray' %> hits the primitive.
              Let's consider the case of a sphere:
            </p>
            <%= tex_image 'find-all-hits' %>
            <p>
              The ray (yellow) hits the sphere in two locations $H_1$ and $H_2$. For each hit, the following information has to be computed:
            </p>
            <ul>
              <li>
                The <%= link 'glossary/math/ray', '$t$-value' %> indicating where on the ray the intersection is positioned. If $t &gt; 0$,
                the hit is located in front of the ray's origin, which is generally the intersection we are interested in.
              </li>
              <li>
                The local position: where on the sphere the hit is located, expressed in the sphere's own coordinate system.
              </li>
              <li>
                The (global) position: where the hit is located, expressed in the world's coordinate system.
              </li>
              <li>
                The normal vector: a vector of length 1 that is perpendicular on the sphere at the hit position.
              </li>
              <li>
                The material: what material the primitive is made of at that point.
              </li>
              <li>
                The group id: this allows you to specify which primitives form a whole. This is important for <%= link 'extensions/renderers/cartoon', 'edge detection' %>.
              </li>
            </ul>
            <p>
              The difference between the local and the global position only becomes apparent when primitives are moved around.
              Say, for example, that the ray goes through the top of the sphere. The sphere itself is centered at $(0,0,0)$.
              Both the local and global position are then equal to $(0,1,0)$. If we were to move the sphere to $(5,1,2)$,
              the local position would still be $(0,1,0)$, but the global
              position would become $(5,2,2)$. In other words, the local hit position is not affected by transformations, but
              the global position is.
            </p>
            <p>
              All these pieces of information correspond to member variables of the RayTracer's <code>Hit</code> structure.
              A primitive does not have to update each field, but only those that apply to the primitive in question.
              A sphere primitive will have to fill out the t-value, the local and global position, and the normal.
              The material and group id are ignored: these are the responsibility of other primitives (namely
              the decorator and group primitive, respectively.)
            </p>
          </section>
          <section>
            <h3>find_all_hits for decorators</h3>
            <p>
              Let's now consider the decorator primitive. A decorator object has two member variables:
            </p>
            <ul>
              <li>
                The child primitive: the primitive being decorated.
              </li>
              <li>
                The material: the "paint" used to decorate the child primitive.
              </li>
            </ul>
            <p>
              So, how does <code>find_all_hits</code> work in the case of decorators? It's very simple:
              since a primitive and a decorated primitive have exactly the same shape,
              the hits will also be the same. This means that a decorator object can simply
              ask its child primitives for its hit list. Go take a look at the code to see how this happens.
            </p>
            <p>
              Once the decorator gets hold of the hit list returned by the child primitive,
              it has to update the <code>Hit</code> objects somehow, otherwise the decorator wouldn't be much use.
              For every hit in the list, it updates the material member variable, thereby
              assigning a material to the hit.
            </p>
          </section>
          <section>
            <h3>find_all_hits for transformers</h3>
            <p>
              A transformer primitive has two components: a transformation (which in turn keeps 2 matrices)
              and a primitive. What does a transformer need to do when asked for its hit list?
            </p>
            <p>
              To better understand what happens, let's again venture into a completely different situation.
              Say you want to make a monster movie about a 100m tall monster, but you only have
              the budget to buy a small 10cm stuffed animal. How do you make it look big and terrifying?
              The answer is simple: you place the camera very low to the ground and make it look up
              towards your stuffed animal.
            </p>
            <p>
              In our RayTracer, the same problem arises: we only support small spheres, yet we need
              to make it look big. Instead of growing the sphere, we choose to shrink the camera.
              Earlier we mentioned the transformer also needed the inverse transformation:
              this is the reason why. If we want to enlarge a primitive 20 times, we need to be able
              to miniaturize the camera 20 times.
            </p>
            <p>
              Say a transformer is initialized with matrices $M$ and $M^{-1}$. When asked to give a list of hits,
              it proceeds as follows:
            </p>
            <ol>
              <li>
                It performs the inverse transformation on the ray, using $M^{-1}$.
              </li>
              <li>
                It asks the child primitive for all hits with this transformed ray.
              </li>
              <li>
                It transforms each hit using $M$.
              </li>
            </ol>
            <p>
              Let's apply this on an example:
            </p>
            <%= tex_image 'transformer-hits' %>
            <p>
              We have a sphere with radius 3 (solid white circle), which is actually a regular sphere of radius 1 (dashed white circle) scaled by a factor 3.
              We want to find the intersections of the ray $O + \vec\Delta t$ with this big sphere (lower yellow line).
            </p>
            <ol>
              <li>
                We shrink the ray by a factor 3. This gives the ray $O' + \vec\Delta' t$ (upper yellow line).
              </li>
              <li>
                We ask the small sphere for its intersections. It returns $H'_1$ and $H'_2$.
              </li>
              <li>
                We "enlarge" these hits, giving $H_1$ and $H_2$, which are returned by the transformer's <code>find_all_hits</code> member function.
              </li>
            </ol>
          </section>
        </section>
        <section>
          <h2>bounding_box</h2>
        </section>
      </section>
    </div>
  </body>
  <script>
    function initialize()
    {
      Box.initialize();
      SourceEditor.initialize();
    }

    $( initialize );   
  </script>
</html>
