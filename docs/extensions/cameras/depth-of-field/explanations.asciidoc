= Angle Animation

[overview]
----
requires samplers/random
reading cameras/depth-of-field
reading design/cameras
----

preview::preview[]

== Explanation

The depth of field camera can be parameterized as follows:

* The eye, a ``Point3D``.
* The look at point (``Point3D``), which specifies what the camera is looking at.
  This point is also the focal point: objects around this location will be sharp, far away objects will look blurry.
* The up vector (``Vector3D``).
* The <<reference/design/cameras#, distance>> (``double``) between the eye and the canvas.
* The <<reference/design/cameras#, aspect ratio>> (``double``) of the canvas.
* The eye size (``double``).
* The eye sampler (``Sampler``).

The depth of field camera can be seen as a multiple-eyed perspective camera.

.Single perspective camera
image::perspective-camera.png[align="center"]

.Multiple eyes looking at same point
image::eyes.png[align="center"]

Given a point on the canvas, the perspective camera only shoots one ray through it.
This ray has its origin in the eye, i.e. stem:[(0,0,0)].

A depth of field camera's eye is not a single point, but a square.
Ideally, for a given point stem:[P] on the canvas, the depth of field camera would should a ray from every point of this square through stem:[P], but since there are infinitely many, this is not a realistic option.
Instead, we pick a finite number of points spread across the eye area and cast rays from these, thereby
hopefully approximating the ideal case.

The eye's size is determined by the eye size parameter.
The larger the eye, the more blurry out-of-focus objects will appear.
We suggest a starting value of 0.5.
The choice of points within the eye area is left to the eye sampler.

== Implementation

Let's start off with the definition of a ``DepthOfFieldPerspectiveCamera`` class.

[TASK]
====
* Create new files ``cameras/depth-of-field-perspective-camera.cpp`` and ``cameras/depth-of-field-perspective-camera.h``.
* Define the class ``DepthOfFieldPerspectiveCamera`` in an anonymous namespace (i.e. a namespace with no name, see ``primitives/sphere-primitive.cpp`` for an example.)
  ``DepthOfFieldPerspectiveCamera`` should be a subclass of ``DisplaceableCamera``.
* ``DepthOfFieldPerspectiveCamera`` has one member variable: a list of ``Camera`` objects.
  These will be a bunch of perspective cameras with slightly different eyes.
* ``DepthOfFieldPerspectiveCamera``'s constructor takes two parameters: a ``Matrix4x4`` transformation matrix, and a list of ``Camera``s.
  The transformation matrix is passed along to the base class's constructor.
  The list of ``Camera``s is used to initialize the member variable you declared earlier.
* ``DepthOfFieldPerspectiveCamera`` overrides one member function: ``enumerate_untransformed_rays`` (from ``DisplaceableCamera``.)
** It takes two parameters: ``point`` and ``callback``.
** Add sanity checks: write assertions (``assert``) that verify that ``point``'s ``x`` and ``y``-coordinates are indeed between ``0`` and ``1``.
** Next, iterate over the ``Camera`` list and call ``enumerate_rays`` on each of them, passing along ``point`` and ``callback`` as arguments.
+
The ``callback`` parameter is a function that ``enumerate_untransformed_rays`` must call for each ray it produces.
  Working this way should be more efficient than accumulating ``Ray`` objects in lists (less memory needed, no heap allocation necessary.)
====

The factory function is where most complexity lies. The function will first create a series of
"almost-canonical" perspective cameras, i.e. cameras located around stem:[(0,0,0)], looking
straight in front of them in the direction of positive Z-axis, and with up vector stem:[(0,1,0)].
A separate transformation step will position the camera at the right spot.

[TASK]
====
Declare the factory function ``depth_of_field_perspective`` in the header file.
It should be a member of the ``raytracers::cameras`` namespace.
See other header files for help.
Its parameters were enumerated earlier on this page.

* Define the factory function in the ``cpp`` file.
* Sanity check: ``up`` must be a unit vector.
* Create the transformation matrix using ``create_transformation``.
  This function expects an ``eye``, a ``look_at`` and an ``up`` vector.
* Define a ``canonical_look_at`` point. It should lie on the Z-axis and as far away from stem:[(0,0,0)] as the ``eye`` point is from the ``look_at`` point.
* Initialize an empty list of ``Camera``s named ``cameras``.
* Create the ``eye_area``, which is a ``Rectangle2D``.
  Derive from the figures above where this ``Rectangle2D`` should be positioned.
* Ask the ``sampler`` to pick points from the ``eye_area``.
* Create a new ``PerspectiveCamera`` for each such point stem:[P], where you use stem:[P] as the camera's eye.
  All cameras should share ``relative_look_at``, and have stem:[(0,1,0)] as ``up``-vector. ``distance`` and ``aspect_ratio`` should also be the same for each camera.
* Put each ``PerspectiveCamera`` in the list ``cameras``.
* Finally, create a ``DepthOfFieldPerspectiveCamera``, initializing it with the transformation matrix and the list of ``Camera``s.
  Wrap it inside a ``Camera`` (same as in ``cameras/perspective-camera.cpp``.)
====

[TASK]
====
Add the finishing touches.

* Add the camera to the list of cameras in ``cameras/cameras.h``.
* Open ``scripting/cameras-module.cpp``. Add an extra member function ``depth_of_field``.
  Add a binding in ``create_cameras_module``.
* In the same file, try to create ``depth_of_field_by_map`` and bind it.
  This would allow you to create a depth of field camera using the keyword parameter syntax (i.e. ``Cameras.depth_of_field( [ "eye": pos(0,0,0), ... ] )``).
====