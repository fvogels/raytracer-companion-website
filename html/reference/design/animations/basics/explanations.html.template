<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Design: Animations</title>
    <%= stylesheets('3dcg', 'box2') %>
    <%= scripts('jquery', 'jquery-ui', 'underscore', 'ace/ace', 'source-editor') %>
    <style>
      img.large {
        width: 80%;
      }

      table.centered {
        margin: 10px auto;
      }

      table th {
        width: 30%;
        text-align: left;
        background: #AAA;
        padding: 2px;
      }

      dt {
        font-weight: bold;
      }
    </style>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      Design: Animations
    </header>
    <div id="contents">
      <section>
        <h1>Basic Types</h1>
        <p>
          An animation is, as is explained on this page regarding the <%= link 'reference/math/animations', 'mathematics behind animations' %>,
          a function which associates each moment in time with a value. This value can be of any type:
          ``double``, ``Angle``, ``Point3D``, &hellip.
        </p>
        <p>
          The ray tracer's animation module has three types at its core:
        </p>
        <ul>
          <li>
            ``Duration`` models duration. This class is comparable to time spans. For example, "5 seconds" is
            a possible values for ``Duration``.
          </li>
          <li>
            ``TimeStamp`` represents a moment in time. You can compare this to a date or time of day.
          </li>
          <li>
            ``Animation&lt;T&gt;`` models an animation of a ``T``. For example ``Animation&lt;double&gt;``
            represents a ``double`` animation. 
          </li>
        </ul>
        <p>
          We take a detailed look at each in turn.
        </p>

        <section>
          <h2>``Duration``</h2>
          <p>
            ``Duration`` objects are created using factory functions:
          </p>
          <ul>
            <li>
              ``Duration::zero()`` creates a duration of 0 seconds.
            </li>
            <li>
              ``Duration::infinite()`` represents an infinitely long duration.
            </li>
            <li>
              ``Duration::from_milliseconds(double)`` and ``Duration::from_seconds(double)``
              allow you to create ``Duration``s from milliseconds and seconds, respectively.
            </li>
          </ul>
          <p>
            C++ allows us to define custom literals. These come in handy for durations.
            For example, say you want to create a ``Duration`` of 4 seconds,
            you can write ``4_s``. It also works with milliseconds: ``4000_ms``.
          </p>
          <p>
            Note that this only works with compile time constants: you cannot
            have some variable ``x = 5`` and then use ``x_s`` to
            create a ``Duration`` of 5 seconds. In this case,
            you have no other choice than to rely on a regular factory function (e.g. ``TimeStamp::from_seconds(double)``.)
          </p>
          <p>
            Some standard operators have also been defined on durations, such as
            ``+``, ``-``, ``*``, ``/``, ``&lt;``, ``&gt;``, ``&lt;=``,
            ``&gt;=``, ``==`` and ``!=``.
          </p>
        </section>

        <section>
          <h2>``TimeStamp``</h2>
          <p>
            As explained above, a ``TimeStamp`` represents a specific moment in time.
            An important ``TimeStamp`` value is the <em>zero time</em> $T_0$, also referred to as the <em>epoch</em>, which in essence corresponds to "the beginning of time".
            Animations will generally start at this moment. Other ``TimeStamp`` values are expressed as
            "time passed since epoch". For example, an animation that takes 5 seconds starts at $T_0$ and ends at $T_0 + 5\mathrm{s}$.
          </p>
          <p>
            To create ``TimeStamp``s, we once again rely on factory functions:
          </p>
          <ul>
            <li>
              ``TimeStamp::zero()`` return the zero time $T_0$.
            </li>
            <li>
              ``TimeStamp::from_epoch(const Duration&amp; d)`` creates a ``TimeStamp`` representing
              the moment $T_0 + d$. For example, $T_0 + 5\mathrm{s}$ is created using ``TimeStamp::from_epoch(5_s)``.
            </li>
          </ul>
          <p>
            The operators ``&lt;``, ``&lt;=``, ``&gt;``, ``&gt;=``, ``==``, ``!=``
            have been defined for ``TimeStamp``s. You can add ``Duration``s ``TimeStamp``s and subtract
            two ``TimeStamp``s from each other.
          </p>
        </section>

        <section>
          <h2>``Animation&lt;T&gt;``</h2>
          <p>
            ``Animation&lt;T&gt;`` represents an animation.
            Its most important member function is ``operator ()``:
            given an ``Animation`` object ``anim`` and a ``TimeStamp timestamp``, you can write
            anim(timestamp) to ask the animation what its value is at the given time.
          </p>
          <p>
            For example, say you create a ``double`` animation called ``anim`` that goes
            from ``10`` to ``20`` in 5 seconds.
          </p>
          <table class="centered">
            <thead>
              <tr>
                <th>
                  Code
                </th>
                <th>
                  Result
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  ``anim(0_s)``
                </td>
                <td>
                  ``10``
                </td>
              </tr>
              <tr>
                <td>
                  ``anim(2.5_s)``
                </td>
                <td>
                  ``15``
                </td>
              </tr>
              <tr>
                <td>
                  ``anim(5_s)``
                </td>
                <td>
                  ``20``
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            For the purposes of creating animations, the ``seconds()`` member function will also come in handy:
            ``timestamp.seconds()`` returns the number of seconds passed since zero time.
            For example, ``TimeStamp::from_epoch(5_s).seconds()`` returns ``5``.
          </p>
          
          <section>
            <h3>Creation</h3>
            <p>
              There are multiple ways of creating animations, but the most straightforward
              way consists of making use of <em>lambda functions</em>. Let's dive right into it with a simple example.
            </p>
            <p>
              Let's create a ``double`` animation that goes from ``0`` to ``1`` in 1 second.
              If we were to write this as a regular function, we would get
            </p>
            <%= source 'basic-animation-function.cpp' %>
            <p>
              This function receives a ``TimeStamp``, looks at how many seconds have past since zero time in seconds,
              and uses that as return value. This means that after 0 seconds, it returns 0, after 0.5 seconds, it returns 0.5, etc.
            </p>
            <p>
              This function takes a ``TimeStamp`` and returns a ``double``.
              Say we want to store this function in a variable (the function itself, not its return value!), what
              type should this variable have? C++ offers a type ``std::function`` which
              represents types of functions.
            </p>
            <%= source 'function-type.cpp' %>
            <p>
              Take a good look at its syntax: it has the form ``std::function&lt;R(T1, T2, ...)&gt;``
              where ``T1``, ``T2``, &hellip; are the parameter types and ``R`` is the
              return type of the function.
            </p>
            <p>
              A lambda function is a function you define inline, as follows:
            </p>
            <%= source 'basic-animation-lambda.cpp' %>
            <p>
              There are multiple advantages to write it as a lambda function. One is that you don't have
              to define a separate ``animate`` function thereby avoiding cluttering the current scope.
              Compare this to local variables versus member variables (fields): a member variable is visible
              to <em>all</em> member functions of the object, while a local variable is only visible inside
              the member function it is defined in. You should always restrict visibility as much as possible;
              using lambda functions allows you to keep function definitions hidden within another function.
            </p>
            <p>
              Once you've defined a ``std::function&lt;double(TimeStamp)&gt;``, you can
              wrap it into a ``Function`` object with the ``from_lambda`` helper function.
              In this specific context, this is admittedly a rather redundant step,
              but it was done to keep things consistent with other parts of the ray tracer. For now,
              you will have to accept that you have to wrap a lambda function into a ``Function`` object.
            </p>
            <p>
              This ``Function`` can be used to define an animation using ``make_animation``.
              Put together, the code to create a basic animation looks like this:
            </p>
            <%= source 'basic-animation.cpp' %>
            <p>
              What if we want to create a ``double`` animation that goes from ``0`` to
              ``5`` in 1 second? We can hardcode it:
            </p>
            <%= source 'basic-animation-hardcode.cpp' %>
            <p>
              But as you know, hardcoding is rarely a good solution. If we were to need a ``0`` to ``7``
              or a ``0`` to ``100`` animation, we would have to duplicate this code each time.
              We'd rather create a function that does the job for us:
            </p>
            <%= source 'basic-animation-factory.cpp' %>
            <p>
              Note how the lambda function makes use of the ``to`` variable, which is a local
              variable in the surrounding scope. ``to`` is said to be a <em>captured variable</em>.
              C++ requires you to be explicit about capturing: you need to mention each
              captured variable in the lambda function's <em>capture list</em>. This list appears
              just before the parameter list, between square brackets. In our case, this list is ``[to]``.
            </p>
            <p>
              There are two ways to capture variables: you can capture them either <em>by value</em> or
              <em>by reference</em>. ``to`` is captured by value: this means that the lambda function
              receives a copy. This is the safest way to go about it.
            </p>
            <p>
              To capture a variable by reference, you need to prefix it with an ampersand (``&amp;``). For example,
              to capture ``to`` by reference, the capture list would become
              ``[&amp;to]``. This is more efficient for large objects and allows
              you to write to the captured variable, but it is more dangerous as you
              need to ensure that the variable still exists when the lambda function is called.
            </p>
            <p>
              In our case, ``to`` should definitely not be passed by reference:
              it is a parameter of ``create_basic_animation``, which means
              that it disappears after ``create_basic_animation`` returns.
              For example, the code below has undefined behavior:
            </p>
            <%= source 'undefined-behavior.cpp' %>
          </section>
          <section>
            <h3>Example: Generalized Double Animation</h3>
            <p>
              We now generalize the basic animation so that we can choose an initial value $a$, a final value $b$ and a duration $\tau$.
              Using the <%= link 'reference/math/animations', 'mathematical formulae' %>, we get
              \[
                X(t) = t \qquad f(x) = a + (b - c) \cdot x \qquad g(t) = \frac{t}{\tau}
              \]
              Combining these yields
              \[
                f \circ X \circ g = f(X(g(t))) = f(X(\frac{t}{\tau})) = f(\frac{t}{\tau}) = a + (b-c) \cdot \frac{t}{\tau}
              \]
              Translated to C++, this gives
            </p>
            <%= source 'generalized-animation.cpp' %>
          </section>
          <section>
            <h3>Example: Color Animation</h3>
            <p>
              Animations can act as building blocks. For example, let's create an animation
              that animates a color.
            </p>
            <%= source 'color-animation.cpp' %>
          </section>
        </section>
      </section>
    </div>
  </body>
  <script>
    function initialize()
    {
      SourceEditor.initialize();
    }

    $( initialize );   
  </script>
</html>
