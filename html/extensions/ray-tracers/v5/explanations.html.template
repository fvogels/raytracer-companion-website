<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Ray Tracer v5</title>
    <%= stylesheets('ucll', 'box2') %>
    <%= scripts('jquery', 'jquery-ui', 'underscore', 'ace/ace', 'source-editor') %>
    <style>
      img.large {
        width: 60%;
      }

      video {
        margin: 10px auto;
      }
    </style>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      Ray Tracer v5
    </header>
    <div id="contents">
      <section>
        <h1>Preview</h1>
        <%= raytrace_movie 'demo' %>
        <%= source 'demo.chai' %>
      </section>
      <section>
        <h1>Explanation</h1>
        <p>
          Reflection is conceptually very simple, but implementing it requires some modifications to the ray tracer structure.
          Fortunately, no changes will need to be made to existing ray tracers; all structural changes can be local to v5.
        </p>

        <section>
          <h2>How Reflection Works</h2>
          <p>
            When a light ray reaches a reflective material, part of it gets reflected in a mirror-like fashion.
          </p>
          <%= tex_image 'reflection' %>
          <p>
            As always with ray tracing, we need to work backwards. How does reflection fit into the ray tracing process?
          </p>
          <p>
            We start off in our eye $E$, from which a ray $R$ is cast into the scene. The ray hits the scene
            at some position $P$, and the material at that location happens to be reflective.
            The idea behind ray tracing is to find out which photons arriving at $P$ bounce back in the direction of $R$.
            To find this out, we reflect our own ray $R$ at $P$ and look which other scene objects it bumps into.
          </p>
          <%= tex_image 'reflection2' %>
          <p>
            Concretely, implementing reflection works as follows:
          </p>
          <ol>
            <li>
              We cast, as always, a ray $R$ starting in the eye $E$.
            </li>
            <li>
              We find out where $R$ hits the scene. Call this location $P$.
            </li>
            <li>
              Determine the color of $P$ as usual.
            </li>
            <li>
              As extra step, we let $R$ be reflected at position $P$. The normal vector $\vec n$ at $P$ will, as with specular highlights, determine
              the reflection's direction. Let's call the reflected ray $R'$.
            </li>
            <li>
              Now, we start the process all over again: we imagine our eye $E$ is located at $P$, and we trace $R'$.
            </li>
            <li>
              $R'$ hits the scene in some point $P'$. We determine the color. This color will be perceived as a reflection at $P$.
            </li>
          </ol>
          <p>
            For example, say that $P$ is, after computing <%= link 'reference/lighting/ambient', 'ambient' %>,
            <%= link 'reference/lighting/diffuse', 'diffuse' %> and <%= link 'reference/lighting/specular', 'specular' %>, determined to be blue.
            If the material were nonreflective, we'd stop here. Otherwise, we go for another round of merry ray tracing:
            we follow the reflection of $R$, and find that it hits some red sphere. We now know that this red sphere
            will be visible at $P$: we add red to the previously computed blue color, yielding violet.
          </p>
        </section>

        <section>
          <h2>Recursive Ray Tracing</h2>
          <p>
            When a ray reaches a reflective material, ray tracing has to start all over again. This means
            that the algorithm will be recursive. Conceptually, it will look like this:
          </p>
          <%= source 'recursive.pseudo' %>
          <p>
            There are two detail we need to take into account:
          </p>
          <ul>
            <li>
              Infinite recursion can occur if a ray gets caught between reflective materials.
            </li>
            <li>
              Materials are not necessarily 100% reflective. As mentioned before,
              only <em>part</em> of the photons get reflected.
            </li>
          </ul>
          <p>
            One solution solves both problems: we associate a <em>reflectivity</em> with each material,
            which is a number between <code>0</code> and <code>1</code> indicating how many
            photons get reflected. A nonreflective material has reflectivity <code>0</code>.
          </p>
          <p>
            We update the pseudocode to take into account reflectivity:
          </p>
          <%= source 'recursive2.pseudo' %>
          <p>
            However, we have not yet solved the problem of infinite recursion.
            Say we create a scene full of objects with reflectivity 0.9.
            We cast our ray beginning in the $E$. It hits the scene at $P$.
            Since the material is reflective, we create a new ray
            starting in $P$ and trace it. We know that the resulting color
            will be multiplied by $0.9$. The secundary ray hits the scene in $P'$.
            Again we reflect the ray, but we know this color will only count for $0.9 \times 0.9 = 0.81$.
            As the ray continuous bouncing around, the resulting's color effect will diminish at each step:
            \[
              1 \quad 0.9 \quad 0.81 \quad 0.729 \quad 0.6561 \quad 0.59049 \quad 0.531441 \quad 0.4782969 \quad \dots
            \]
          </p>
          <p>
            After a number of reflections we will arrive at a point where the next computed color will only matter
            for less than $1\%$. We can easily stop tracing there without it visibly affecting the result.
            The $1\%$ threshold is chosen arbitrarily: if you prefer you can choose a higher or lower value.
            Higher values mean tracing will end sooner and hence will reduce rendering times.
          </p>
          <%= tex_image 'weight' %>
          <p>
            To implement this, we need to pass along the "weight" to the <code>trace</code> function.
            The weight indicates how much the result of the call will count in the final result.
            <code>trace</code> can then choose to immediately return black if this weight is below $1\%$.
            This way, recursion is guaranteed to end, as long as with each recursive call,
            <code>trace</code> passes along an updated version of the weight which is lower than its own.
          </p>
          <%= source 'recursive3.pseudo' %>
          <aside class="boxed2">
            <h1>Task</h1>
            <p>
              Implement <code>RayTracerV5</code>. We give you the following hints:
            </p>
            <ul>
              <li>
                You will need to add a new <code>trace</code> overload. It takes the same arguments
                as the original <code>trace</code> function and adds a <code>double weight</code> parameter.
              </li>
              <li>
                <code>RayTracerV5</code> overrides <code>trace</code>. It calls the new <code>trace</code> overload,
                passing it <code>1.0</code> as <code>weight</code>.
              </li>
              <li>
                The new <code>trace</code> will behave the same as the old <code>trace</code>, but will,
                after calling <code>compute_ambient</code> and <code>process_lights</code>, perform
                a third call, to <code>compute_reflection</code>.
              </li>
              <li>
                <code>compute_reflection</code> will need to be able to call <code>trace</code> recursively.
                It is important that you call the new overload, and that you always pass along the correct weight.
                Make sure to pass all necessary data to <code>compute_reflection</code> using parameters
                so that it can perform its job.
              </li>
            </ul>
          </aside>
        </section>
      </section>
    </div>
  </body>

  <script>
    function initialize()
    {
      SourceEditor.initialize();
    }

    $( initialize );   
  </script>
</html>
