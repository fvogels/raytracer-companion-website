<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Depth of Field Camera</title>
    <%= stylesheets('3dcg', 'box2') %>
    <%= scripts('jquery', 'jquery-ui', 'underscore', 'ace/ace', 'source-editor') %>
    <style>
      img.large {
        width: 60%;
      }

      video {
        margin: 10px auto;
      }
    </style>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      Depth of Field Camera
    </header>
    <div id="contents">
      <%= overview(prerequisites: ['samplers/random'],
                   reading_material: ['cameras/depth-of-field', 'design/cameras']) %>
      <section>
        <h1>Preview</h1>
        <%= raytrace_movie 'demo' %>
        <%= source 'demo.chai' %>
      </section>
      <section>
        <h1>Explanation</h1>
        <p>
          The depth of field camera can be parameterized as follows:
        </p>
        <ul>
          <li>
            The eye, a ``Point3D``.
          </li>
          <li>
            The look at point (``Point3D``), which specifies what the camera is looking at. This point is also the focal point:
            objects around this location will be sharp, far away objects will look blurry.
          </li>
          <li>
            The up vector (``Vector3D``).
          </li>
          <li>
            The <%= link 'reference/design/cameras', 'distance' %> (``double``) between the eye and the canvas.
          </li>
          <li>
            The <%= link 'reference/design/cameras', 'aspect ratio' %> (``double``) of the canvas.
          </li>
          <li>
            The eye size (``double``).
          </li>
          <li>
            The eye sampler (``Sampler``).
          </li>
        </ul>
        <p>
          The depth of field camera can be seen as a multiple-eyed perspective camera.
        </p>
        <table style="width: 80%; margin: 10px auto;">
          <tbody>
            <tr>
              <td><%= tex_image('perspective-camera', style: 'width:100%') %></td>
              <td><%= tex_image('eyes', style: 'width:100%') %></td>
            </tr>
          </tbody>
        </table>
        <p>
          Given a point on the canvas, the perspective camera only shoots one ray through it.
          This ray has its origin in the eye, i.e. $(0,0,0)$.
        </p>
        <p>
          A depth of field camera's eye is not a single point, but a square.
          Ideally, for a given point $P$ on the canvas, the depth of field camera would
          should a ray from every point of this square through $P$, but since there are
          infinitely many, this is not a realistic option. Instead, we pick
          a finite number of points spread across the eye area and cast rays from these, thereby
          hopefully approximating the ideal case.
        </p>
        <p>
          The eye's size is determined by the eye size parameter. The larger the eye, the more
          blurry out-of-focus objects will appear. We suggest a starting value of 0.5.
          The choice of points within the eye area is left to the eye sampler.
        </p>
      </section>
      <section>
        <h1>Implementation</h1>
        <p>
          Let's start off with the definition of a ``DepthOfFieldPerspectiveCamera`` class.
        </p>
        <aside class="boxed2">
          <h1>Task</h1>
          <ul>
            <li>
              Create new files ``cameras/depth-of-field-perspective-camera.cpp`` and
              ``cameras/depth-of-field-perspective-camera.h``.
            </li>
            <li>
              Define the class ``DepthOfFieldPerspectiveCamera`` in an anonymous namespace
              (i.e. a namespace with no name, see ``primitives/sphere-primitive.cpp`` for an example.)
              ``DepthOfFieldPerspectiveCamera`` should be a subclass of ``DisplaceableCamera``.
            </li>
            <li>
              ``DepthOfFieldPerspectiveCamera`` has one member variable: a list of ``Camera`` objects.
              These will be a bunch of perspective cameras with slightly different eyes.
            </li>
            <li>
              ``DepthOfFieldPerspectiveCamera``'s constructor takes two parameters:
              a ``Matrix4x4`` transformation matrix, and a list of ``Camera``s.
              The transformation matrix is passed along to the base class's constructor.
              The list of ``Camera``s is used to initialize the member variable you declared earlier.
            </li>
            <li>
              ``DepthOfFieldPerspectiveCamera`` overrides one member function: ``enumerate_untransformed_rays``
              (from ``DisplaceableCamera``.)
              <ul>
                <li>
                  It takes two parameters: ``point`` and ``callback``.
                </li>
                <li>
                  Add sanity checks: write assertions (``assert``) that verify that ``point``'s ``x``
                  and ``y``-coordinates are indeed between ``0`` and ``1``.
                </li>
                <li>
                  Next, iterate over the ``Camera`` list and call ``enumerate_rays`` on each of them,
                  passing along ``point`` and ``callback`` as arguments.
                </li>
              The ``callback`` parameter is a function that ``enumerate_untransformed_rays``
              must call for each ray it produces. Working this way should be more efficient than accumulating
              ``Ray`` objects in lists (less memory needed, no heap allocation necessary.)
            </li>
          </ul>
        </aside>
        <p>
          The factory function is where most complexity lies. The function will first create a series of
          "almost-canonical" perspective cameras, i.e. cameras located around $(0,0,0)$, looking
          straight in front of them in the direction of positive Z-axis, and with up vector $(0,1,0)$.
          A separate transformation step will position the camera at the right spot.
        </p>
        <aside class="boxed2">
          <h1>Task</h1>
          <ul>
            <li>
              Declare the factory function ``depth_of_field_perspective`` in the header file.
              It should be a member of the ``raytracers::cameras`` namespace. See other header files for help.
              Its parameters were enumerated earlier on this page.
            </li>
            <li>
              Define the factory function in the ``cpp`` file.
              <ul>
                <li>
                  Sanity check: ``up`` must be a unit vector.
                </li>
                <li>
                  Create the transformation matrix using ``create_transformation``. This function
                  expects an ``eye``, a ``look_at`` and an ``up`` vector.
                </li>
                <li>
                  Define a ``canonical_look_at`` point. It should lie on the Z-axis and as far away
                  from $(0,0,0)$ as the ``eye`` point is from the ``look_at`` point.
                </li>
                <li>
                  Initialize an empty list of ``Camera``s named ``cameras``.
                </li>
                <li>
                  Create the ``eye_area``, which is a ``Rectangle2D``.
                  Derive from the figures above where this ``Rectangle2D`` should be positioned.
                </li>
                <li>
                  Ask the ``sampler`` to pick points from the ``eye_area``.
                </li>
                <li>
                  Create a new ``PerspectiveCamera`` for each such point $P$, where you use
                  $P$ as the camera's eye. All cameras should share ``relative_look_at``,
                  and have $(0,1,0)$ as ``up``-vector. ``distance`` and
                  ``aspect_ratio`` should also be the same for each camera.
                </li>
                <li>
                  Put each ``PerspectiveCamera`` in the list ``cameras``.
                </li>
                <li>
                  Finally, create a ``DepthOfFieldPerspectiveCamera``,
                  initializing it with the transformation matrix and the list of ``Camera``s.
                  Wrap it inside a ``Camera`` (same as in ``cameras/perspective-camera.cpp``.)
                </li>
              </ul>
            </li>
          </ul>
        </aside>

        <aside class="boxed2">
          <h1>Task</h1>
          <p>
            Add the finishing touches.
          </p>
          <ul>
            <li>
              Add the camera to the list of cameras in ``cameras/cameras.h``.
            </li>
            <li>
              Open ``scripting/cameras-module.cpp``. Add an extra member function ``depth_of_field``.
              Add a binding in ``create_cameras_module``.
            </li>
            <li>
              In the same file, try to create ``depth_of_field_by_map`` and bind it.
              This would allow you to create a depth of field camera using the keyword parameter syntax
              (i.e. ``Cameras.depth_of_field( [ "eye": pos(0,0,0), ... ] )``).
            </li>
          </ul>
        </aside>
      </section>
    </div>
  </body>

  <script>
    function initialize()
    {
      SourceEditor.initialize();
    }

    $( initialize );   
  </script>
</html>
