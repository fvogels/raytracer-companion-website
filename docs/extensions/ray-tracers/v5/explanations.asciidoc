= Ray Tracer v5

[overview]
----
difficulty 3
requires ray-tracers/v4
----

preview::preview[]

== How It Works

The <</extensions/ray-tracers/v3/explanations#,previous version of the ray tracer>>, objects were considered 100% opaque: they would block 100% of the light.
However, we would like objects to be able to be translucent, i.e., that they can only block part of the light.

Below we have three disks that each let through certain colors.
The shadows shows what light "survives".

video::translucency.mp4[align="center"]

White light (`FFF`) travels from the top to the plane below.

* If it only encounters the cyan disk (`0FF`), then red (`F00`) gets blocked.
* If the light beam needs to get through both the cyan disk (`0FF`) and the magenta disk (`F0F`), only blue (`00F`) survives.
* If light encounters all three disks, all photons are blocked, resulting in a full black shadow.

[NOTE]
====
Admittedly, the disks themselves don't look very translucent.
This extension focuses solely on the shadows.
Actually translucent looking disks will be possible in <</extensions/ray-tracers/v7/explanations#,ray tracer v7>>.

video::translucency2.mp4[align="center"]
====

== Implementation

The previous ray tracer version operated in a very simple way: to render some position stem:[P], it iterates through all light sources stem:[L] and checks if there is any object between stem:[L] and stem:[P].
This was achieved by taking the light ray, which travels from stem:[L] through stem:[P] and find an intersection with the scene.
If there is an intersection where stem:[0 < t < 1], there is something obstructing the light from getting from stem:[L] to stem:[P], causing us to disregard all photons originating from stem:[L], which is how shadows form.

We will add some nuance to this approach.
An updated form of the algorithm goes as follows:

[source,language='python']
----
hits = scene.find_all_hits(light_ray)
filter = white

for hit in [ h for h in hits if 0 < h.t < 1 ]:
    # Determine material properties at hit
    matprops = ...

    # Use color multiplication
    filter *= mp.light_filtering

# Make new light ray
surviving_light_ray = LightRay(original_light_ray.ray,
                               original_light_ray.color * filter)

# Delegate further work to previous implementation
return RayTracerV3.process_light_ray(surviving_light_ray)
----

Notice how we rely on `MaterialProperties::light_filtering` to determine how much light a primitive lets through.

* If `light_filtering` equals black, no light gets through.
  This is the default.
* If `light_filtering` equals white, all light gets through.
  Such an object will never cast shadows.
* If `light_filtering` equals red, only red light will get through.
  Such an object will cast a red shadow.

[TASK]
====
* Create new files `raytracers/ray-tracer-v5.cpp` and `raytracers/ray-tracer-v5.h`.
* Implement a class `RayTracerV5` that inherits from `RayTracerV4`.
** An autogenerated default constructor will suffice, i.e., you do not need to define any constructors.
** The class only needs to override ``process_light_ray``.
   The algorithm is given in Pythonesque code above.
====
