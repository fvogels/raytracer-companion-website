= Ray Tracer v2

[overview]
----
requires ray-tracers/v1
reading lighting/diffuse
----

preview::preview[]

== Implementation

<</extensions/ray-tracers/v1/explanations#,Ray tracer v1>> added support for <</reference/lighting/ambient/explanations#,ambient lighting>>.
This ray tracer adds another kind of lighting, namely <%= link 'reference/lighting/diffuse', 'diffuse lighting' %>. Take some time to read up on it.


When ray tracing a scene, our goal is to be able to simulate each photon so that we know which effect it has on
our final image. Ray tracer v1 only took into consideration a small fraction of these photons,
namely only those due to ambient lighting. Ray tracer v2 will also take into account photons that
are the product of diffuse lighting.

[stem]
++++
  \begin{array}{rcl}
    \textrm{v1} & = & \textrm{ambient photons} \\
    \textrm{v2} & = & \textrm{ambient photons} + \sum_{L \in \textrm{lights}} \textrm{diffuse photons from } L \\
  \end{array}
++++

We suggest the following design for v2. It might help to refactor v1 a bit so that you can make v2 a subclass
of v1 and reuse functionality.

image::uml.png[align="center",width="600"]

We now discuss each of the methods' responsibilities in turn.

== `trace`

The algorithm in ``trace``'s body looks as follows: given a scene and a ray,

. Determine the first positive hit between the ray and the scene.
. If there is no hit, return a ``TraceResult::no_hit``.
. Initialize a ``Color result`` to ``colors::black()``, i.e. with start with zero photons.
. Ask the ``hit.material`` for the ``MaterialProperties`` at the hit location.
. Compute the ambient lighting (as you did in v1) and add the color to ``result``.
. Call ``process_lights``, which will iterate over all lights. Add the return value (a color) to ``result``.
. Return a ``TraceResult`` containing all necessary data, with as color ``result``'s final value.

[TASK]
====
Create two new files ``raytracers/ray-tracer-v2.cpp`` and ``raytracers/ray-tracer-v2.h``.
Add the necessary declarations in the header file (let the above UML class diagram guide you).

Add the definition for ``trace`` in the ``.cpp`` file.
====

== `process_lights`

This method's sole responsibility is to iterate over each light and return the sum of all colors.

. Start with a fresh ``Color result`` set to black.
. Iterate over the scene's light sources. Call ``process_light_source`` for each light source
  and add the return value to ``result``.
. Return ``result``.

[TASK]
====
Implement ``process_lights``.
====

== `process_light_source`

This method asks the given light source to enumerate all light rays it emits in the direction of the hit position
and passes each to ``process_light_ray``.
For point lights, there is only one such ray, but area lights can produce many.


[%header,.center,cols="^,^"]
|===
| Point Light | Area Light
| image:point-light.png[]
| image:area-light.png[]
|===

Note how light sources produce ``LightRay`` objects, not just ``Ray``s. A ``LightRay``
is a ``Ray`` combined with a ``Color``, meaning it specifies not only where the light comes from,
but also which color it is.

``process_light_source`` operates as follows:

. Initialize a local variable ``result`` of type ``Color`` to black.
. Ask the light source to enumerate all light rays that reach ``hit.position``.
. Iterate over each of these light rays. Give each to ``process_light_ray``.
  Add the return values to ``result``.
. Return ``result``.

[TASK]
====
Implement ``process_light_source``.
====

== `process_light_ray`

In v2, ``process_light_ray`` is very simple:

. Initialize local variable ``result`` to black.
. Call ``compute_diffuse`` and add its return value to ``result``.
. Return ``result``.

[TASK]
====
Implement ``process_light_ray``.
====

Admittedly, this method seems like an unnecessary indirection, and at this stage, it is.
We chose to introduce it here so as to simplify the definition of v3: writing this
ray tracer will be a matter of overriding this method.

== `compute_diffuse`

Finally comes the time to actually compute diffuse lighting.
The arguments provide you with all necessary data. You need:

* The direction of the incoming light.
* The light's color.
* The position to be lit.
* The normal vector at the position to be lit.

[TASK]
====
Translate the <</reference/lighting/diffuse/explanations#,mathematical formula for diffuse lighting>> into code.
====

[TIP]
====
* You can make use of ``Vector3D::normalized`` to normalize the vector, i.e. you can translate
+
[stem]
++++
\frac{L-P}{|L-P|}
++++
to ``(L - P).normalized()``.
* Make sure to use the right multiplication: stem:[a \cdot b] corresponds to ``a.dot(b)`` if
  both stem:[a] and stem:[b] are vectors, otherwise you need to use ``*``.
====

[TASK]
====
Put the finishing touches.

* Create the factory method ``raytracer::raytracers::v2()``.
* Add the appropriate include to ``raytracers/ray-tracers.h``.
* Update ``scripting/raytracing-module.cpp``.
====


[TASK]
====
Check your work extensivily. Render a scene
where you can see the lit and unlit parts of an object.
Make sure the results look good.

Make sure that, while setting up the scene, you pick a low
value for the ambient color, such as ``0.1 * colors::white()``. For example, if you were to set
ambient to ``colors::white()``, the object
would already be maximally illuminated and the diffuse lighting
would simply "drown" in the ambient lighting.
It's as if you point a flashlight to the sun.
====
