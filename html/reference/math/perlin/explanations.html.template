<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Perlin Noise</title>
    <%= stylesheets('ucll', 'box2') %>
    <%= scripts('jquery', 'jquery-ui', 'underscore', 'ace/ace', 'source-editor') %>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      Perlin Noise
    </header>
    <div id="contents">
      <section>
        <h1>Deterministic Continuous Random Functions</h1>
        <p>
          To procedurally generate textures, we generally need a source of randomness.
          Libraries often offer this functionality in the form of a function
          that returns a new value each time it's called.
        </p>
        <p>
          A problem with these random number generators is that they are "too random" for our purposes.
          Consider the graphs below:
        </p>
        <table style="width: 80%; margin: 10px auto;">
          <tbody>
            <tr>
              <td><%= tex_image('chaotic-terrain', style:'width: 80%;') %></td>
              <td><%= tex_image('smooth-terrain', style:'width: 80%;') %></td>
            </tr>
          </tbody>
        </table>
        <p>
          Perlin noise is in essence a random number generator that guarantees a certain smoothness.
          Concretely, what we what is some function <code>double random(double x)</code> that satisfies the following conditions:
        </p>
        <ul>
          <li>
            <code>random</code> must be deterministic: <code>random(x)</code> must return the same result when given the same <code>x</code>.
          </li>
          <li>
            <code>random</code> must be continuous: <code>random(x)</code> and <code>random(x + 0.00001)</code> should be close to each other, i.e. no sudden jumps.
          </li>
        </ul>
        <p>
          Perlin noise satisfies these criteria.
        </p>
        <p>
          The function <code>double random(double x)</code> is one-dimensional: it associates a value with each <code>double</code>.
          We can lift this to higher dimensions:
        </p>
        <ul>
          <li>
            <code>double random(const Point2D&amp;)</code> is a two dimensional variant: it associates a value with each <code>Point2D</code>.
          </li>
          <li>
            <code>double random(const Point3D&amp;)</code> is three dimensional: each point in 3D space is mapped to a value.
          </li>
        </ul>
      </section>
      <section>
        <h1>Perlin Noise</h1>
        <p>
          Perlin noise is such a deterministic continuous function. For the remainder of this page, we will work in 2D, i.e.
          we will build a function <code>double perlin(const Point2D&amp;)</code>.
        </p>
        <p>
          Perlin noise works as follows: take a 2D grid of 1 &times; 1 cells and associate a unit vector with every intersection.
        </p>
        <%= tex_image 'grid-vectors' %>
        <p>
          In order to determine the value associated with a point $P(x, y)$, you need
          to find out in which grid cell it resides. Its corners are
          \[
            Q_1(\lfloor x \rfloor, \lfloor y \rfloor) \qquad
            Q_2(\lfloor x \rfloor, \lceil y \rceil) \qquad
            Q_3(\lceil x \rceil, \lceil y \rceil) \qquad
            Q_4(\lceil x \rceil, \lfloor y \rfloor) \qquad
          \]
          where $\lfloor x \rfloor$ corresponds to rounding $x$ down and $\lceil x \rceil$ to rounding $x$ up.
          Each corner has a unit vector associated with it. We denote the vector corresponding to $Q_i$ with $\vec v_i$.</p>
        <p>
          Next, take the dot product of each $Q_iP$ and $v_i$:
          \[
            z_i = (P - Q_i) \cdot v_i
          \]
        </p>
        <%= tex_image 'computation' %>
        <p>
          Now we have associated a $z$-value with each corner. As last step, we need to determine
          which $z$-value to assign to $P$ itself using interpolation.
        </p>
        <%= tex_image 'interpolation' %>
        <p>
          Interpolation goes in three steps:
        </p>
        <ul>
          <li>
            Find a function $f$ with $f(0) = z_1$ and $f(1) = z_4$. Compute $f(x)$.
          </li>
          <li>
            Find a function $f$ with $g(0) = z_2$ and $f(1) = z_3$. Compute $g(x)$.
          </li> 
          <li>
            Find a function $h$ with $h(0) = f(x)$ and $h(1) = g(x)$. Compute $h(y)$.
          </li> 
        </ul>
        <p>
          The functions $f$, $g$ and $h$ can be linear or, for better results, an <%= link 'reference/math/easing-function', 'easing functions' %>.
        </p>
      </section>
    </div>
  </body>
  <script>
    function initialize()
    {
      SourceEditor.initialize();
    }

    $( initialize );   
  </script>
</html>
