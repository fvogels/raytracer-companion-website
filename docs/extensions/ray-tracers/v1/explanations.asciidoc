= Ray Tracer v1

[overview]
----
difficulty 1
reading lighting/ambient
----

preview::preview[]

== Introducing Ray Tracer v1

Go take a look at the code for the original ray tracer in ``raytracers/ray-tracer-v0``.
The ``trace`` member function must (among other things), given a ray and a scene, determine which object in the scene is hit by the ray first
and find out what color this object has.

Ray tracer v0 is a rather lazy implementation: if there's a hit, it simply returns white instead
of actually trying to find out which color the object has. Ray tracer v1 will improve upon it.


[TASK]
====
Add the following files to the project:

* ``raytracers/ray-tracer-v1.cpp``
* ``raytracers/ray-tracer-v1.h``

Copy the contents of ``raytracers/ray-tracer-v0.cpp`` and ``raytracers/ray-tracer-v0.h`` into them.
Update the code for the name change, e.g.

* In ``ray-tracer-v1.h``, change the class name from ``RayTracerV0`` to ``RayTracerV1``.
* In ``ray-tracer-v1.h``, change the factory function's name from ``v0`` to ``v1``.
* In ``ray-tracer-v1.cpp``, change ``#include "raytracers/ray-tracer-v0.h"`` to ``#include "raytracers/ray-tracer-v1.h"``.
* And so on.

To check your work,

* Create a new demo file by copying ``basic-sample`` and updating it so as to use ray tracer ``v1`` instead of ``v0``.
  You may have to take a look into the superclass ``Demo`` to get this done.
* Don't forget to update ``app.cpp`` so that it makes use of the new demo.
* Compile.
* Run. It should produce exactly the same results as before your change.
====

== Ambient Lighting

Ray tracer v1 adds support for <%= link 'reference/lighting/ambient', 'ambient lighting' %>. Be sure to read the linked material
as otherwise you will not understand what you need to implement.

There are multiple ways to introduce ambient lighting to our RayTracer. We chose to associate an ambient lighting
factor to materials: you can create a sphere with a lot of ambient lighting and one just next to the
sphere with no ambient lighting at all. This is highly unrealistic, but it's up to the creator of the scene to avoid such pitfalls.

[TASK]
====
In order to add support for ambient lighting, you need to update ``RayTracerV1::trace`` as follows:

* The function should start with finding the first positive hit between the given ray and the given scene.
* If a hit is found, the ``hit`` object will contain all necessary information you need to continue.
  Most noteworthy is the ``hit`` object's ``material`` field, which contains information
  about the material that's been hit by the ray. For example, if the ray hits a tree, the ``material`` field
  will contain information about wood.
* Materials are not necessarily uniform. For example, wood is seldom homogeneously brown but contains lines and rings.
  This means there is not one single material color. Instead of asking the material "What is your color?",
  you need to ask "What is your color _at that location_?" This is done using the ``at`` method:
  it takes a ``Point3D`` and returns a ``MaterialProperties`` object that contains location-specific information.
* The ``Point3D`` you need to pass to ``Material::at`` is the primitive's _local_ hit position.
  You can find it in the ``hit`` object (it was initialized by ``find_first_positive_hit``).
* ``trace`` must return a ``TraceResult``, which has four components. The ``group_id``,
  ``ray`` and ``hit`` parts can be initialized in the same way is in ``RayTracerV0``.
  The color component is different though: instead of always using white, you should return the color returned by the material.
  You can find it in the ``MaterialProperties`` object.
====

It is of paramount importance that you _always_ check that your changes work.

[TASK]
====
Run your project. Everything should look black since instead of returning white you return the material's ambient color, which is black.

Now modify ``basic-sample.cpp`` so that the sphere has a red as ambient color (use ``colors::red()``).
Compile and run to see if it works.
====

== Scripting

We want to make our new ray tracer available for scripting. For each extension we make, we need to "export" it
to the scripting language.

[TASK]
====
Open the file ``scripting/raytracing-module.cpp``.
====

Right now, the scripting language knows only about one ray tracer, namely v0. You can create it within the scripting
language as follows: ``var raytracer = Raytracers.v0()``. Our goal is to make ``Raytracers.v1()``
create a v1 ray tracer.

``v0`` and ``v1`` are in essence ray tracer factories. We grouped all ray tracer factories
into some kind of package named ``Raytracers``. The same thing applies for other kinds of factories,
for example, all samplers can be created using ``Samplers.<span style="font-style: italic;">name</span>()``,
such as ``Samplers.single()`` or ``Samplers.nrooks(3)``.

In order to have these factories grouped in a package, we need to create a {cpp} object
that contains all these factories. If you go take a look in ``scripting/raytracing-module``, you'll
see that there is a struct called ``RaytracerLibrary`` which contains a member function ``v0()``.
This member function has the sole responsibility of creating a ``v0`` ray tracer object.

To inform the scripting language of this library object, we undertake the following steps (see
``raytracer::scripting::_private_::create_raytracing_module`` in ``scripting/raytracing-module``):

. We create the library object.
. We declare a constant ``Raytracers`` within the scripting language which
  is then linked with the object. This is done using ``module-&gt;add_global_const``.
. Next, we must expose each member function in turn. This is achieved
  with ``module-&gt;add``. Since the syntax is not trivial
  and this needs to be done for each ray tracer version,
  we defined a macro ``BIND`` that takes most of the syntactic burden
  away from us: if ``RaytracerLibrary`` has a member function F,
  you can expose it using ``BIND(F)``.

We do not put all factories within packages, as it would become too much of a syntactic
burden for often used factories. For example, primitives can be created
using top level functions, i.e. you simply write ``sphere()`` instead
of ``Primitives.sphere()``.

An example of how to export something as a top level function is ``create_scene``.
In {cpp}, ``create_scene`` is a top level function. ``module-&gt;add`` recognizes
this fact and mirrors it by exposing ``create_scene`` as a top level function inside the scripting language.

[TASK]
====
Add a binding for ``v1``.

Examine the ``v(int)`` function and update it as necessary.

Check your work by creating a script that uses ray tracer v1 and rendering it.
====
