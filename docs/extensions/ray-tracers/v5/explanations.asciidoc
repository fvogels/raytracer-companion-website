= Ray Tracer v5

[overview]
----
difficulty 3
requires ray-tracers/v4
----

preview::preview[]

== How It Works

The <</extensions/ray-tracers/v3/explanations#,previous version of the ray tracer>>, objects were considered 100% opaque: they would block 100% of the light.
However, we would like objects to be able to be translucent, i.e., that they can only block part of the light.

Below we have three disks that each let through certain colors.
The shadows shows what light "survives".

video::translucency.mp4[align="center"]

White light (`FFF`) travels from the top to the plane below.

* If it only encounters the cyan disk (`0FF`), then red (`F00`) gets blocked.
* If the light beam needs to get through both the cyan disk (`0FF`) and the magenta disk (`F0F`), only blue (`00F`) survives.
* If light encounters all three disks, all photons are blocked, resulting in a full black shadow.

[NOTE]
====
Admittedly, the disks themselves don't look very translucent.
This extension focuses solely on the shadows.
Actually translucent looking disks will be possible in <</extensions/ray-tracers/v7/explanations#,ray tracer v7>>.

video::translucency2.mp4[align="center"]
====

== Material Properties

We need a way to specify how much light gets through an object.
For this, an extra `MaterialProperties` field will be necessary.

[TASK]
====
In `materials/material-properties.cpp` and its corresponding header file,

* Add a field `light_filtering` of type `Color`.
* Let the constructor accept an extra parameter to initialize this field with.
====

[TASK]
====
Update the `MaterialPropertiesBuilder` class.
====

[TASK]
====
Update `scripting/materials-module.cpp` so that we can specify `light_filtering` in the scripting language.
====

== RayTracerV5

The previous ray tracer version operated in a very simple way: to render some position stem:[P], `process_light_ray` checks if there is any object between the light source's position stem:[L] and stem:[P].
This was achieved by taking the light ray, which travels from stem:[L] through stem:[P] and find an intersection with the scene.
If there is an intersection where stem:[0 \leq t < 1], there is something obstructing the light from getting from stem:[L] to stem:[P], causing us to disregard all photons originating from stem:[L], creating a shadow.

image::code-structure.svg[align="center"]

We will add some nuance to this approach.
An improved form of the `process_light_ray` algorithm goes as follows:

[source,language='python']
----
def (scene, matprops, hit, eye_ray, light_ray):
  hits = scene.find_all_hits(light_ray)
  color_filter = white

  for hit in [ h for h in hits if 0 < h.t < 1 ]:
      # Determine material properties at hit
      matprops = ...

      # Use color multiplication
      color_filter *= matprops.light_filtering

  # Make new light ray
  surviving_light_ray = LightRay(original_light_ray.ray,
                                 original_light_ray.color * color_filter)

  # Delegate further work to previous implementation
  return super().process_light_ray(scene, matprops, hit, eye_ray, surviving_light_ray)
----

Notice how we rely on `MaterialProperties::light_filtering` to determine how much light a primitive lets through.

* If `light_filtering` equals black, no light gets through.
  This is the default.
* If `light_filtering` equals white, all light gets through.
  Such an object will never cast shadows.
* If `light_filtering` equals red, only red light will get through.
  Such an object will cast a red shadow.

[TASK]
====
* Create new files `raytracers/ray-tracer-v5.cpp` and `raytracers/ray-tracer-v5.h`.
* Implement a class `RayTracerV5` that inherits from `RayTracerV4`.
* The class only needs to override ``process_light_ray``.
  The algorithm is given in Pythonesque code above.
====

== Binding

[TASK]
====
Add bindings so that `v5` becomes accessible from the scripting language.
====

== Evaluation

TODO
