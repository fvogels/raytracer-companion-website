<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Ray Tracer v2</title>
    <%= stylesheets('3dcg', 'box2') %>
    <%= scripts('jquery', 'jquery-ui', 'underscore', 'ace/ace', 'source-editor') %>
    <style>
      img.large {
        width: 60%;
      }

      video {
        margin: 10px auto;
      }

      .centered {
        margin: 0px auto;
      }

      #lights-comparison {
        width: 60%;
      }

      #lights-comparison th {
        background: #AAA;
      }
    </style>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      Ray Tracer v2
    </header>
    <div id="contents">
      <section>
        <%= overview(prerequisites: ['ray-tracers/v1'],
                     reading_material: ['lighting/diffuse']) %>
        <h1>Preview</h1>
        <%= raytrace_movie 'demo' %>
        <%= source 'demo.chai' %>
      </section>
      <section>
        <h1>Implementation</h1>
        <p>
          <%= link 'extensions/ray-tracers/v1', 'Ray tracer v1' %> added support for <%= link 'reference/lighting/ambient', 'ambient lighting' %>.
          This ray tracer adds another kind of lighting, namely <%= link 'reference/lighting/diffuse', 'diffuse lighting' %>. Take some time to read up on it.
        </p>
        <p>
          When ray tracing a scene, our goal is to be able to simulate each photon so that we know which effect it has on
          our final image. Ray tracer v1 only took into consideration a small fraction of these photons,
          namely only those due to ambient lighting. Ray tracer v2 will also take into account photons that
          are the product of diffuse lighting.
          \[
            \begin{array}{rcl}
              \textrm{v1} &amp; = &amp; \textrm{ambient photons} \\
              \textrm{v2} &amp; = &amp; \textrm{ambient photons} + \sum_{L \in \textrm{lights}} \textrm{diffuse photons from $L$} \\
            \end{array}
          \]
        </p>
        <p>
          We suggest the following design for v2. It might help to refactor v1 a bit so that you can make v2 a subclass
          of v1 and reuse functionality.
        </p>
        <%= tex_image 'uml' %>
        <p>
          We now discuss each of the methods' responsibilities in turn.
        </p>
        <section>
          <h2>trace</h2>
          <p>
            The algorithm in ``trace``'s body looks as follows: given a scene and a ray,
          </p>
          <ol>
            <li>
              Determine the first positive hit between the ray and the scene.
            </li>
            <li>
              If there is no hit, return a ``TraceResult::no_hit``.
            </li>
            <li>
              Initialize a ``Color result`` to ``colors::black()``, i.e. with start with zero photons.
            </li>
            <li>
              Ask the ``hit.material`` for the ``MaterialProperties`` at the hit location.
            </li>
            <li>
              Compute the ambient lighting (as you did in v1) and add the color to ``result``.
            </li>
            <li>
              Call ``process_lights``, which will iterate over all lights. Add the return value (a color) to ``result``.
            </li>
            <li>
              Return a ``TraceResult`` containing all necessary data, with as color ``result``'s final value.
            </li>
          </ol>
          <aside class="boxed2">
            <h1>Task</h1>
            <p>
              Create two new files ``raytracers/ray-tracer-v2.cpp`` and ``raytracers/ray-tracer-v2.h``.
              Add the necessary declarations in the header file (let the above UML class diagram guide you).
            </p>
            <p>
              Add the definition for ``trace`` in the ``.cpp`` file.
            </p>
          </aside>
        </section>
        <section>
          <h2>``process_lights``</h2>
          <p>
            This method's sole responsibility is to iterate over each light and return the sum of all colors.
          </p>
          <ol>
            <li>
              Start with a fresh ``Color result`` set to black.
            </li>
            <li>
              Iterate over the scene's light sources. Call ``process_light_source`` for each light source
              and add the return value to ``result``.
            </li>
            <li>
              Return ``result``.
            </li>
          </ol>
          <aside class="boxed2">
            <h1>Task</h1>
            <p>
              Implement ``process_lights``.
            </p>
          </aside>
        </section>
        <section>
          <h2>``process_light_source``</h2>
          <p>
            This method asks the given light source to enumerate all light rays it emits in the direction of the hit position
            and passes each to ``process_light_ray``.
            For point lights, there is only one such ray, but area lights can produce many.
          </p>
          <table class="centered" id="lights-comparison">
            <thead>
              <tr>
                <th>Point Light</th>
                <th>Area Light</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><%= tex_image 'point-light' %></td>
                <td><%= tex_image 'area-light' %></td>
              </tr>
            </tbody>
          </table>
          <p>
            Note how light sources produce ``LightRay`` objects, not just ``Ray``s. A ``LightRay``
            is a ``Ray`` combined with a ``Color``, meaning it specifies not only where the light comes from,
            but also which color it is.
          </p>
          <p>
            ``process_light_source`` operates as follows:
          </p>
          <ol>
            <li>
              Initialize a local variable ``result`` of type ``Color`` to black.
            </li>
            <li>
              Ask the light source to enumerate all light rays that reach ``hit.position``.
            </li>
            <li>
              Iterate over each of these light rays. Give each to ``process_light_ray``.
              Add the return values to ``result``.
            </li>
            <li>
              Return ``result``.
            </li>
          </ol>
          <aside class="boxed2">
            <h1>Task</h1>
            <p>
              Implement ``process_light_source``.
            </p>
          </aside>
        </section>
        <section>
          <h2>``process_light_ray``</h2>
          <p>
            In v2, ``process_light_ray`` is very simple:
          </p>
          <ol>
            <li>
              Initialize local variable ``result`` to black.
            </li>
            <li>
              Call ``compute_diffuse`` and add its return value to ``result``.
            </li>
            <li>
              Return ``result``.
            </li>
          </ol>
          <aside class="boxed2">
            <h1>Task</h1>
            <p>
              Implement ``process_light_ray``.
            </p>
          </aside>
          <p>
            Admittedly, this method seems like an unnecessary indirection, and at this stage, it is.
            We chose to introduce it here so as to simplify the definition of v3: writing this
            ray tracer will be a matter of overriding this method.
          </p>
        </section>
        <section>
          <h2>``compute_diffuse``</h2>
          <p>
            Finally comes the time to actually compute diffuse lighting.
            The arguments provide you with all necessary data. You need:
          </p>
          <ul>
            <li>
              The direction of the incoming light.
            </li>
            <li>
              The light's color.
            </li>
            <li>
              The position to be lit.
            </li>
            <li>
              The normal vector at the position to be lit.
            </li>
          </ul>
          <aside class="boxed2">
            <h1>Task</h1>
            <p>
              Translate the <%= link 'reference/lighting/diffuse', 'mathematical formula for diffuse lighting' %> into code.
            </p>
            <ul>
              <li>                
                You can make use of ``Vector3D::normalized`` to normalize the vector, i.e.
                you can translate
                \[
                  \frac{L-P}{|L-P|}
                \]
                to ``(L - P).normalized()``.
              </li>
              <li>
                Make sure to use the right multiplication: $a \cdot b$ corresponds to ``a.dot(b)`` if
                both $a$ and $b$ are vectors, otherwise you need to use ``*``.
              </li>
            </ul>
          </aside>
          
          <aside class="boxed2">
            <h1>Task</h1>
            <p>
              Put the finishing touches.
            </p>
            <ul>
              <li>
                Create the factory method ``raytracer::raytracers::v2()``.
              </li>
              <li>
                Add the appropriate include to ``raytracers/ray-tracers.h``.
              </li>
              <li>
                Update ``scripting/raytracing-module.cpp``.
              </li>
            </ul>
          </aside>
          
          <aside class="boxed2">
            <h1>Task</h1>
            <p>
              Check your work extensivily. Render a scene
              where you can see the lit and unlit parts of an object.
              Make sure the results look good.
            </p>
            <p>
              Make sure that, while setting up the scene, you pick a low
              value for the ambient color, such as ``0.1 * colors::white()``. For example, if you were to set
              ambient to ``colors::white()``, the object
              would already be maximally illuminated and the diffuse lighting
              would simply "drown" in the ambient lighting.
              It's as if you point a flashlight to the sun.
            </p>
          </aside>
        </section>
      </section>
            
    </div>
  </body>

  <script>
    function initialize()
    {
      SourceEditor.initialize();
    }

    $( initialize );   
  </script>
</html>
