= Mesh

== Rendering Complex Shapes

A mesh is a large collection of triangles forming a complex shape. Any shape can be built out of triangles,
as long as you have enough of them. For example, the preview below is built out of 10 million triangles.

video::preview.mp4[align="center"]

The problem with having meshes consisting of millions of triangles is obvious: rendering times go through the roof.
We need to find a way to speed it up quite a bit if we want to be able to admire the results within our lifetime.

There are many ways to speed things up. You are free to implement any approach you wish, but
in these pages, we will discuss one particular technique, namely bounding boxes.

The idea behind bounding boxes is simple. Say you have a mesh consisting of a million triangles,
then for every ray shot out of the eye, you normally would compute its intersection with each
of the million triangles, which amounts to a lot of work. We want to cut that number down.
We can achieve that by enclosing all those triangles into a tight-fitting box. Then,
for each ray, we would first check if the ray intersects with the box. If it doesn't,
the ray will not intersect any triangles inside the box. We just saved ourselves a million hit-checks.
Of course, if the ray does intersect the box, we're back to square one and have
to deal with all million triangles.

We could, however, add more boxes. Say we divide the large all-encompassing box into two additional
smaller boxes: the upper half and the lower half. Each box would contain approximately half a million triangles.
Then, if the ray intersects the large box, we check which of the two smaller boxes it intersects.
If we're lucky, the ray misses one of the smaller boxes and we avoided half a million hit-checks.

We can continue this process recursively: we split each box into smaller boxes, thereby
creating a bounding box hierarchy. We continue to do so until each single box contains
only a small number of triangles. When tracing a ray, we only need to consider
the contents of boxes it actually intersects. This way, instead of having to process
a million triangles, we can get away with, say, a hundred.

The building of this bounding box hierarchy takes time. Fortunately, this needs to be done only once for each mesh:
once done, we can write the hierarchy to file and read it whenever the mesh pops up in a scene.
This means, however, that we need to build a tool separate from the ray tracer, one that
reads in all triangles, builds the bounding box hierarchy and stores it to file.
The ray tracer itself will have to be extended with a module that is able to read this file
back in and use it to rebuild the mesh.

=== Step One: Finding Meshes

First, you need to find a mesh to render. You can build one yourself using
a 3D modelling tool such as https://www.blender.org[Blender], or
you could just look for a premade one online. We've provided you with a few
meshes <</meshes#'meshes', 'here', check: false) %>.

Just like there are many different graphics formats (png, jpeg, bmp, &hellip;),
there exists a diversity of mesh formats such as ply, obj, etc.
If you want to make use of one of these formats, it is your responsibility
to find out how to read them.

Since reading in a mesh file is not our focus, the <%= raw_link('meshes', 'meshes we provide', check: false) %>
are stored in a very simple file format. In order to understand it, you must know what it's meant to contain:
triangles. The most straightforward format would be to store one triangle per line: ``x1 y1 z1 x2 y2 z2 x3 y3 z3``.
However, since some meshes are composed of millions of triangles, mesh files would quickly grow very large, literally GBs in size.

There is a rather easy way to reduce a mesh's storage requirements: a vertex is generally shared by multiple triangles.

image::vertices.svg[align="center"]

In the picture above, the centered vertex is shared by four triangles, while all others

* The first line contains an integer V representing the number of vertices.
* The next V lines contain three floating point numbers. These represent the XYZ coordinates of V vertices.
* The next line contains a single integer T. This represents the number of triangles.
* Lastly, T lines containing three integers i, j and k follow. Each line represents a triangle whose vertices are denoted by their indices.

For example, the following file encodes a mesh consisting of a single triangle:

[source,language=text]
----
3
0 0 0
1.5 2.1 3.2
-1.2 1.1 5.6
1
0 1 2
----

=== Step Two: Creating the Bounding Box Hierarchy

This step involves creating a separate tool that

* reads in the mesh found in step one,
* builds the bounding box hierarchy, and
* stores the result in a file.

There are <</reference/primitives/mesh/optimization/explanations#,many ways>> to build a hierarchy:
you can work top down (starting with a large box and dividing it into smaller boxes) or bottom
up (starting with small boxes and combining them into large boxes). There is no single right way
to build the hierarchy. To compare algoritmhs, we can measure

* The time it takes to build a hierarchy.
* The time it takes to render the mesh.

Since the first part (building the hierarchy) needs only occur once, the rendering
times are by far the most important aspect.

Storing the bounding box hierarchy in a file can again be done in many ways.
First, you'll have to choose between text or binary format. Using text format
is a bit easier, but much slower.

Next, you have to encode the vertices, triangles and bounding boxes.
Let's focus solely on the latter two. Say you have the following hierarchy:

image::hierarchy.svg[align="center"]

One way would be to work with a stack based format: you start off with an empty stack.
Whenever a triangle is added, it is added to this stack. Whenever a box is defined,
the last two items on the stack are popped of, put in a box, which in turn
is again pushed on the stack. For the diagram shown above, this results in:

[source,language=text]
----
triangle i1 j1 k1       # Vertex-indices of T1
triangle i2 j2 k2       # Vertex-indices of T2
box                     # Groups last two triangles together
triangle i3 j3 k3
triangle i4 j4 k4
box
box                     # Groups last two boxes together
triangle i5 j5 k5
triangle i6 j6 k6
box
triangle i7 j7 k7
triangle i8 j8 k8
box
box
box
----

Another possibility is to work with indices, similarly to how triangles and vertices work:
triangles and boxes are numbered, and a box refers to what it contains using indices.
This yields

[source,language=text]
----
triangle i1 j1 k1       # Index 0
triangle i2 j2 k2       # Index 1
box 0 1                 # Index 2
triangle i3 j3 k3       #       3
triangle i4 j4 k4       #       4
box 3 4                 #       5
box 2 5                 #       6
triangle i5 j5 k5       #       7
triangle i6 j6 k6       #       8
box 7 8                 #       9
triangle i7 j7 k7       #       10
triangle i8 j8 k8       #       11
box 10 11               #       12
box 9 12                #       13
box 6 13                #       14
----

=== Step Three: Rendering the Mesh

The last step consists of extending the ray tracer with an extra type of primitive, i.e., the mesh.
This involves reading the file produced in step 2 and using it to create triangles
and bounding box accelerators based on its contents.
