= Optimizing Meshes

== Bounding Box Hierarchies

In order to understand bounding box hierarchies, you need to read up on <</reference/primitives/bounding-box-accelerator/explanations#,bounding box accelerators>> first.

Putting a single bounding box around a mesh only speeds up rendering for those rays
that miss the box. Each time the ray does hit the box, we are again forced
to check all triangles contained within the box for a hit. We need to find a way to avoid this.

What if, instead of having a single box with a bunch of triangles in it, we build a tree of boxes?
We have one large box, which contains two smaller boxes, which in turn also contain two smaller boxes, etc.
We would create a hierarchy stem:[N] levels deep, and the boxes at the very bottom would contain triangles.

image::hierarchy.png[align="center"]

Finding the hits with the ray now goes as follows:

. The ray hits the outer (black) bounding box, meaning its contents (the two red boxes) cannot be skipped.
. Left red box is hit, so is the right red box. We need to consider all blue boxes.
. Of the four blue boxes, the ray does not hit the upper right one. We can therefore skip its contents (the two upper right green boxes and their contents).
. Out of the remaining six green boxes, the ray hits 4.
  Only their contents need to be considered further.

So, if the triangles are evenly divided over all eight green boxes, using this hierarchy, only half of them need to
be taken into account during our search for hits. If we were to create a deeper hierarchy, even more triangles
can be ignored, further speeding up the process.

== A Top Down Approach

There are many ways to build a bounding box hierarchy. We present you with a few general ideas, leaving the details up to you.

A first approach to build a hierarchy goes as follows:

. You start with the set of triangles.
. Build the smallest bounding box containing all of these triangles. This box is the top of your hierarchy.
. Split the box in 2 equal parts. Let's call the two smaller boxes the "left" and "right" box.
. Find out in which of these two boxes each triangle fits. There will be triangles that don't fit in either.
  You can put these in the left box and enlarge it so that it fully envelops these rebel triangles.
. Now you have two boxes each containing triangles. Repeat the above steps as often as you want.

There are multiple possible variations:

* How to split a box in two:
** You can split it up along its largest dimension. E.g. a box with dimensions 8 &times; 6 &times; 10
   is first divided into two boxes of size 8 &times; 6 &times; 5. These two boxes would
   be further divided into two boxes sized 4 &times; 6 &times; 5, and those in turn
   will be divided into 2 &times; 3 &times; 5 boxes, etc.
** You can choose to alternate between splitting alone the X-axis, Y-axis and Z-axis, regardless
   of the box's actual size.
** Instead of cutting a box in two perfect halves, you can split it up so that the left and
   right size contain an equal number of triangles.
* Dealing with "leftover" triangles:
** As mentioned above, you can choose to put them all in the left box, and then enlarge the left box so that it
   contains these extra triangles.
** You could also put the leftover triangles in the right box. Quite the twist.
** You can put them in a separate box, yielding a ternary tree instead of a binary one, i.e.
   each box contains three subboxes instead of 2.
* When to stop dividing boxes in two:
** You could stop after stem:[N] iterations.
** You can continue splitting up until there are less than stem:[N] triangles per box.
** You can stop when a box's volume becomes less than stem:[N].

== A Bottom Up Approach

The previous approach started with a big box and starting splitting it into smaller boxes.
A different take would be to start with the triangles, group them in small boxes,
group these boxes in boxes, etc. until you end up with one single box.

Again, there are many variations possible:

* Which triangles will you group together in boxes?
** You could look for that pair of triangle that leads to the smallest box.
** You could just sort them along the X-, Y- or Z-axis and group consecutive triangles.
   You could stick to one axis, or alternate. You could sort based on the leftmost vertex
   or the triangle's center.
* How many triangles will you put in each box?
