= Mesh

// TODO

[WARNING]
====
This page still needs to change.
You should wait until this message has disappeared to avoid doing unnecessary work.
====

== Rendering Complex Shapes

=== Linear Approximations in 2D

Let's say you're making a 2D game on very old hardware.
You would like to draw this shape:

image::circle.png[align="center",width="25%"]

The attentive reader will notice this is a circle.
However, circles are rather computationally expensive to draw.
Maybe you can find another way?

Lines.
Lines are cheap.
Let's try to approximate our circle using line segments.

image::approx4.png[align="center",width="25%"]

Well, it's an approximation all right.
But it will have to do: your hardware can't handle any better.
However, when you're able to get your hands on something more powerful, you can easily improve your "circle":

[.center,options="header",cols="^.^1,^5",width="60%"]
|===
| Vertex count | Result
| 8 a| image::approx8.png[align="center",width="50%"]
| 16 a| image::approx16.png[align="center",width="50%"]
| 32 a| image::approx32.png[align="center",width="50%"]
| 64 a| image::approx64.png[align="center",width="50%"]
|===

What's nice about this approximation trick is that it is applicable on any shape, however complex it may be.
You can make an arbitrarily close approximation by simply throwing more line segments at it.

=== Linear Approximations in 3D

In 3D, line segments will not do.
We need something better.
Instead of line segments, we use "plane segments".
Or triangles, if you will.

Here they are in action:

video::preview.mp4[align="center"]

We call such a collection of triangles a _mesh_.
Any shape can be built out of triangles, as long as you have enough of them.
For example, our friend the happy Buddha above is built out of a 1,087,716 triangles.

== Dealing with Large Meshes

The problem with having meshes consisting of millions of triangles is obvious: rendering times go through the roof.
We need to find a way to speed it up quite a bit if we want to be able to admire the results within our lifetime.

There are many ways to speed things up.
You are free to implement any approach you wish, but in these pages, we will discuss one particular technique, namely bounding boxes.

The idea behind bounding boxes is simple.
Say you have a mesh consisting of a million triangles, then for every ray shot out of the eye, you normally would compute its intersection with each of the million triangles, which amounts to a lot of work.
We desperately want to cut that number down.

We can achieve that by enclosing all those triangles into a tight-fitting box.
Then, for each ray, we would first check if the ray intersects with the box.
If it doesn't, the ray will not intersect any triangles inside the box.
We just saved ourselves a million hit-checks.
Of course, if the ray _does_ intersect the box, we're back to square one and have to deal with all million triangles.

[source,language="python"]
----
def is_hit(ray, box):
  if ray hits box:
    # Assumes that the contents of the box are all triangles
    return any(is_triangle_hit(ray, triangle) for triangle in box.contents)
  else:
    return False
----

[NOTE,caption="Example"]
====
image::bbh1.png[align="center",width="50%"]

Let's say the mesh consists of stem:[N] triangles.
We build a nice box around them.
The green ray flies by the box containing all triangles.
Only one intersection test is necessary, namely the one with the box.

The red ray, however, does hit the box, so all stem:[N] triangles have to be considered in turn.
Result: stem:[N+1] intersection tests are necessary.
====

We could, however, add more boxes.
Say we divide the large all-encompassing box into two additional smaller boxes: the upper half and the lower half.
Each box would contain approximately half a million triangles.
Then, if the ray intersects the large box, we check which of the two smaller boxes it intersects.
If we're lucky, the ray misses one of the smaller boxes and we avoided half a million hit-checks.

[source,language="python"]
----
def is_hit(ray, object):
  if isinstance(object, Triangle):
    return is_triangle_hit(ray, object)
  else:
    # Note the recursive call: a child can be a BoundingBox
    return any(is_hit(ray, child) for child in object.contents)
----

[NOTE,caption="Example"]
====
image::bbh2.png[align="center",width="50%"]

Again we have stem:[N] triangles.
We put them in one big box.
But inside the big box, we add two smaller boxes, each containing stem:[N/2] triangles.

* The green ray misses the outer box, so only 1 intersection check necessary.
* The blue ray hits the outer box (1 intersection check).
  We check the two inner boxes (2 more intersection checks).
  The left box is hit, so we need to go through all triangles in the left box (stem:[N+2] intersection checks).
  Total: stem:[N/2 + 3] checks.
* The red ray is less lucky.
  We first check if it hits the outer box (1 check), it does.
  Then, we check the two inner boxes (2 checks) and we see it hits both.
  All triangles need to be processed (stem:[N] checks).
  Total: stem:[N+3] checks.
====

We can continue this process recursively: we split each box into smaller boxes, thereby creating a bounding box hierarchy.
We continue to do so until each single box contains only a small number of triangles.
When tracing a ray, we only need to consider the contents of boxes it actually intersects.
This way, instead of having to process a million triangles, we can get away with, say, a hundred.

The building of this bounding box hierarchy takes time.
Fortunately, this needs to be done only once per mesh: once done, we can write the box hierarchy to file and read it whenever the mesh pops up in a scene.
This means, however, that we need to build a tool separate from the ray tracer, one that reads in all triangles, builds the bounding box hierarchy and stores it into a file.

== Actual Implementation

Let's take a step back and review what we need to do.

* First, we need a mesh.
  This mesh will be unoptimized and be nothing more than a large collection of triangles.
* This data will have to be stored in a file.
  We'd like an easy to read file format.
  Let's use the extension `.unoptimized.mesh` for now.
* The mesh needs to be optimized, i.e., we need to arrange the triangles in some bounding box hierarchy.
  This should be done by a separate tool, which can be implemented in any language.
* The new optimized mesh must also be stored in a file.
  This file format will need to be able to encode bounding box hierarchies.
  We can use the `.optimized.mesh` extension.
* Finally, we will need to be able to read this `.optimized.mesh` file in our ray tracer so as to be able to actually render the mesh.

image::process.svg[align="center",width="40%"]

=== Finding a Mesh

We _could_ https://www.blender.org[create our own meshes], but that'd be a lot of work.
Instead, we can just pick a mesh:

[.center,cols="^.^,^.^,^",options="header",width="60%"]
|===
| Name        | #Triangles    | Preview
| Bunny       | 69,451       a| video::bunny.mp4[width="100%"]
| Iron Man    | 217,038      a| video::ironman.mp4[width="100%"]
| Buddha      | 1,087,716    a| video::buddha.mp4[width="100%"]
| Nefertiti   | 2,018,232    a| video::nefertiti.mp4[width="100%"]
| Dragon      | 7,219,045    a| video::dragon.mp4[width="100%"]
| Lucy        | 28,055,742   a| video::lucy.mp4[width="100%"]
|===

=== Unoptimized Mesh Format

There are multiple ways to store meshes:

* https://en.wikipedia.org/wiki/STL_(file_format)[.stl file format]
* https://en.wikipedia.org/wiki/Wavefront_.obj_file[Wavefront .obj file format]
* https://en.wikipedia.org/wiki/PLY_(file_format)[.ply file format]

However, we can be smart about our file format choice.
An unoptimized mesh can be seen as a bunch of triangles grouped in a single box, whereas an optimized mesh adds more depth to the hierarchy (boxes of boxes of boxes of ... of triangles).
This would allow us to use the same format for both unoptimized and optimized meshes.

=== Mesh Format

As discussed in the previous section, we only really need a single format for both unoptimized and optimized meshes.
We can therefore use a single extension `.mesh`.

There's more good news: we have already defined the format for you.
Added to this, you are also provided with a {cpp} class that parses it.
However, you still need to know what the format looks like though: your mesh optimizer needs to be able both to read and write a mesh file.

==== Working Example

First, a bit of explanation so that the mesh format makes more sense.
As you know, a mesh consists of many triangles.
If we were to construct a disk out of triangles, it would look like this:

image::disk.png[align="center",width="25%"]

This disk is made out of 36 triangles.
For the sake of clarity, we simplify this disk to just 4 triangles:

image::vertex-sharing.png[align="center",width="50%"]

==== Naive File Format

Our simplified disk is built out of 4 triangles, each having 3 vertices, each of which have 3 coordinates (x, y, z), each of which are ``double``s which are 8 bytes long, meaning we need to store 4 &times; 3 &times; 3 &times; 8 = 288 bytes.
We could encode this disk as follows:

[source,language="python"]
----
0 0 0    1  0 0    0  1 0      # Triangle 0
0 0 0    0  1 0   -1  0 0      # Triangle 1
0 0 0   -1  0 0    0 -1 0      # Triangle 2
0 0 0    0 -1 0    1  0 0      # Triangle 3
----

==== Improved File Format

Notice, however, that the middle vertex is shared by all triangles, and that all other vertices are shared by two triangles.
In total, there are only 5 unique vertices.
We can make use of this to save on storage.
First, we list all the vertices:

[source,language="python"]
----
 0  0  0   # #0: Central vertex
 1  0  0   # #1: East vertex
 0  1  0   # #2: North vertex
-1  0  0   # #3: West vertex
 0 -1  0   # #4: South vertex
----

Next, we specify the triangles by simply listing their vertices using their index.

[source,language="python"]
----
0 1 2    # Triangle 0 connects vertex 0, vertex 1 and vertex 2
0 2 3    # Triangle 1 connects vertex 0, vertex 2 and vertex 3
0 3 4    # Triangle 2 connects vertex 0, vertex 3 and vertex 4
0 4 1    # Triangle 3 connects vertex 0, vertex 4 and vertex 1
----

Let's count how many bytes of storage we need now.

* First, we listed all 5 vertices, each requiring 3 &times; 8 bytes, which amount to 120 bytes.
* Next, we defined 4 triangles, each using 3 vertex indices.
  These indices are regular ``int``s, so 4 bytes each.
  This means the triangles themselves take up 4 &times; 3 &times; 4 = 48 bytes.
* Total: 120 + 48 = 168 bytes.
  This is much less than the original 288 bytes.

If we were to make the same calculation for the original disk that we built out of 36 triangles, we get 2592 bytes vs 1320 bytes.

There's one problem though: how is a file reader supposed to know where the vertices end and where the triangles start?
Luckily, the solution is simple: we simply add an integer at the very top of the file that tells the reader how many vertices there are.
The entire file thus becomes

[source,language="python"]
----
5            # Number of vertices
 0  0  0     # #0: Central vertex
 1  0  0     # #1: East vertex
 0  1  0     # #2: North vertex
-1  0  0     # #3: West vertex
 0 -1  0     # #4: South vertex
0 1 2        # Triangle 0 connects vertex 0, vertex 1 and vertex 2
0 2 3        # Triangle 1 connects vertex 0, vertex 2 and vertex 3
0 3 4        # Triangle 2 connects vertex 0, vertex 3 and vertex 4
0 4 1        # Triangle 3 connects vertex 0, vertex 4 and vertex 1
----

==== Adding Boxes

Using our file format, we can only specify triangles.
It's great for unoptimized meshes, but as discussed above, we also want to be able to encode bounding box hierarchies.

image::boxes.png[align="center",width="50%"]

Consider the "mesh" above.
It consists of 7 triangles which we've labeled A to G.
The optimizer has grouped A, B and C in a box (drawn in red).
Similary, D and E are grouped in the green box, and F and G in the blue box.
Finally, all three boxes are put into an all-encompassing black box.

The file format looks as follows:

* First part: we list all the vertices, like in the previous section.
* Second part: we encode the hierarchy.
  We distinguish between triangles and boxes.
** A triangle is encoded by a line formatted as `t` _i_ _j_ _k_, where _i_, _j_ and _k_ are vertex indices.
   In other words, the only difference with the previous format is that triangles have an extra `t` at the beginning of the line.
** A box is encoded by a line formatted as `b` _n_`, where _n_ represents the number of children in the box.
   The previous _n_ items that were read are to be used as children.

Our mesh above is encoded as

[source,language='python']
----
21            # Vertex count
...           # Vertices omitted
t 0 1 2       # Triangle A
t 3 4 5       # Triangle B
t 6 7 8       # Triangle C
b 3           # Red box
t 9 10 11     # Triangle D
t 12 13 14    # Triangle E
b 2           # Green box
t 15 16 17    # Triangle F
t 18 19 20    # Triangle G
b 2           # Blue box
b 3           # Black box
----

In order to read this, we need to keep a stack.

* Reading a triangle means adding the triangle to the stack.
* Reading a box means taking the last _n_ items on the stack, putting them in a box, and pushing the box back on the stack.

Below is the code for a mesh reader:

[source,language='python']
----
def read_mesh(file):
  """
  Reads a mesh from file.
  """
  vertices = read_vertices(file)
  return read_hierarchy(file, vertices)


def read_hierarchy(file, vertices):
  # Create empty stack
  stack = []

  while True:
    line = file.readline()

    if line.startswith('t'):  # Current line represents a triangle
      vertices = [vertex[int[i]] for i in line.split(' ')[1:]]
      stack.append(Triangle(vertices))

    elif line.starswith('b'):  # Current line represents a box
      nchildren = int(line.split(' ')[1])

      # Take last nchildren items off the stack
      children = stack[-nchildren:]
      stack = stack[:-nchildren]

      stack.append(Box(children))

    elif line.startswith('end'):
      # Last line in file
      return stack[-1]


def read_vertices(file):
  """
  Reads vertices from file and returns them as an array.
  """
  # Read number of vertices
  nvertices = int(file.readline())

  # Read all vertices
  return [read_vertex(file) for _ in range(nvertices)]


def read_vertex(file):
  """
  Reads in a single line and interprets it as XYZ coordinates.
  """
  return tuple(float(c) for c in file.readline().split(' '))
----

[NOTE,caption="Example"]
====
We go through reading the mesh line by line.

* We begin with an empty stack.
* `t 0 1 2`: we encountered triangle A.
  We add it to the stack, which now contains `[A]`.
* `t 3 4 5`: triangle B, which has to be pushed on the stack: `[A, B]`.
* `t 6 7 8`: triangle C, which has to be pushed on the stack: `[A, B, C]`.
* `b 3`: the red box. We pop the 3 last items from the stack (`A`, `B` and `C`), put them in a box, and we push the box back onto the stack: `[Box(ABC)]`.
* `t 9 10 11`: triangle D, push it on the stack, which now contains `[Box(ABC), D]`
* `t 12 13 14`: triangle E, push it on the stack, which now contains `[Box(ABC), D, E]`
* `b 2`: pop last 2, put in box, push on stack. Result: `[Box(ABC), Box(DE)]`.
* `t 15 16 17`: stack becomes `[Box(ABC), Box(DE), F]`.
* `t 18 19 20`: stack becomes `[Box(ABC) Box(DE), F, G]`.
* `b 2`: stack becomes `[Box(ABC), Box(DE), Box(FG)]`.
* `b 3`: stack becomes `[Box(Box(ABC), Box(DE), Box(FG))]`.
  Note how this box contains other boxes instead of triangles.
* `end`: we reached the end.
  The top of the stack `Box(Box(ABC), Box(DE), Box(FG))` corresponds to the root of the hierarchy.
====
