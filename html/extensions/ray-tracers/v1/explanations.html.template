<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Ray Tracer v1</title>
    <%= stylesheets('3dcg', 'box2') %>
    <%= scripts('jquery', 'jquery-ui', 'underscore', 'ace/ace', 'source-editor') %>
    <style>
      img.large {
        width: 60%;
      }

      video {
        margin: 10px auto;
      }
    </style>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      Ray Tracer v1
    </header>
    <div id="contents">
      <%= overview(reading_material: ['lighting/ambient']) %>
      
      <section>
        <h1>Preview</h1>
        <%= raytrace_movie 'demo' %>
        <%= source 'demo.chai' %>
      </section>

      <section>
        <h1>Introducing ray tracer v1</h1>
        <p>
          Go take a look at the code for the original ray tracer in ``raytracers/ray-tracer-v0``.
          The ``trace`` member function must (among other things), given a ray and a scene, determine which object in the scene is hit by the ray first
          and find out what color this object has.
        </p>
        <p>
          Ray tracer v0 is a rather lazy implementation: if there's a hit, it simply returns white instead
          of actually trying to find out which color the object has. Ray tracer v1 will improve upon it.
        </p>
        <aside class="boxed2">
          <h1>Task</h1>
          <p>
            Add the following files to the project:
          </p>
          <ul>
            <li>
              ``raytracers/ray-tracer-v1.cpp``
            </li>
            <li>
            ``raytracers/ray-tracer-v1.h``
            </li>
          </ul>
          <p>
            Copy the contents of ``raytracers/ray-tracer-v0.cpp`` and ``raytracers/ray-tracer-v0.h`` into them.
            Update the code for the name change, e.g.
          </p>
          <ul>
            <li>
              In ``ray-tracer-v1.h``, change the class name from ``RayTracerV0`` to ``RayTracerV1``.
            </li>
            <li>
              In ``ray-tracer-v1.h``, change the factory function's name from ``v0`` to ``v1``.
            </li>
            <li>
              In ``ray-tracer-v1.cpp``, change ``#include "raytracers/ray-tracer-v0.h"`` to ``#include "raytracers/ray-tracer-v1.h"``.
            </li>
            <li>
              And so on.
            </li>
          </ul>
          <p>
            To check your work,
          </p>
          <ul>
            <li>
              Create a new demo file by copying ``basic-sample`` and updating it so as to use ray tracer ``v1`` instead of ``v0``. You
              may have to take a look into the superclass ``Demo`` to get this done.
            </li>
            <li>
              Don't forget to update ``app.cpp`` so that it makes use of the new demo.
            </li>
            <li>
              Compile.
            </li>
            <li>
              Run. It should produce exactly the same results as before your change.
            </li>
          </ul>
        </aside>
      </section>
      <section>
        <h1>Ambient Lighting</h1>
        <p>
          Ray tracer v1 adds support for <%= link 'reference/lighting/ambient', 'ambient lighting' %>. Be sure to read the linked material
          as otherwise you will not understand what you need to implement.
        </p>
        <p>
          There are multiple ways to introduce ambient lighting to our RayTracer. We chose to associate an ambient lighting
          factor to materials: you can create a sphere with a lot of ambient lighting and one just next to the
          sphere with no ambient lighting at all. This is highly unrealistic, but it's up to the creator of the scene to avoid such pitfalls.
        </p>
        <aside class="boxed2">
          <h1>Task</h1>
          <p>
            In order to add support for ambient lighting, you need to update ``RayTracerV1::trace`` as follows:
          </p>
          <ul>
            <li>
              The function should start with finding the first positive hit between the given ray and the given scene.
            </li>
            <li>
              If a hit is found, the ``hit`` object will contain all necessary information you need to continue.
              Most noteworthy is the ``hit`` object's ``material`` field, which contains information
              about the material that's been hit by the ray. For example, if the ray hits a tree, the ``material`` field
              will contain information about wood.
            </li>
            <li>
              Materials are not necessarily uniform. For example, wood is seldom homogeneously brown but contains lines and rings.
              This means there is not one single material color. Instead of asking the material "What is your color?",
              you need to ask "What is your color <em>at that location</em>?" This is done using the ``at`` method:
              it takes a ``Point3D`` and returns a ``MaterialProperties`` object that contains location-specific information.
            </li>
            <li>
              The ``Point3D`` you need to pass to ``Material::at`` is the primitive's <em>local</em> hit position.
              You can find it in the ``hit`` object (it was initialized by ``find_first_positive_hit``).
            </li>
            <li>
              ``trace`` must return a ``TraceResult``, which has four components. The ``group_id``,
              ``ray`` and ``hit`` parts can be initialized in the same way is in ``RayTracerV0``.
              The color component is different though: instead of always using white, you should return the color returned by the material.
              You can find it in the ``MaterialProperties`` object.
            </li>
          </ul>
        </aside>
        <p>
          It is of paramount importance that you <em>always</em> check that your changes work.
        </p>
        <aside class="boxed2">
          <h1>Task</h1>
          <p>
            Run your project. Everything should look black since instead of returning white you return the material's ambient color, which is black.
          </p>
          <p>
            Now modify ``basic-sample.cpp`` so that the sphere has a red as ambient color (use ``colors::red()``).
            Compile and run to see if it works.
          </p>
        </asidesection>
      </section>
      <section>
        <h1>Scripting</h1>
        <p>
          We want to make our new ray tracer available for scripting. For each extension we make, we need to "export" it
          to the scripting language.
        </p>
        <aside class="boxed2">
          <h1>Task</h1>
          <p>
            Open the file ``scripting/raytracing-module.cpp``.
          </p>
        </aside>
        <p>
          Right now, the scripting language knows only about one ray tracer, namely v0. You can create it within the scripting
          language as follows: ``var raytracer = Raytracers.v0()``. Our goal is to make ``Raytracers.v1()``
          create a v1 ray tracer.
        </p>
        <p>
          ``v0`` and ``v1`` are in essence ray tracer factories. We grouped all ray tracer factories
          into some kind of package named ``Raytracers``. The same thing applies for other kinds of factories,
          for example, all samplers can be created using ``Samplers.<span style="font-style: italic;">name</span>()``,
          such as ``Samplers.single()`` or ``Samplers.nrooks(3)``.
        </p>
        <p>
          In order to have these factories grouped in a package, we need to create a C++ object
          that contains all these factories. If you go take a look in ``scripting/raytracing-module``, you'll
          see that there is a struct called ``RaytracerLibrary`` which contains a member function ``v0()``.
          This member function has the sole responsibility of creating a ``v0`` ray tracer object.
        </p>
        <p>
          To inform the scripting language of this library object, we undertake the following steps (see
          ``raytracer::scripting::_private_::create_raytracing_module`` in ``scripting/raytracing-module``):
        </p>
        <ol>
          <li>
            We create the library object.
          </li>
          <li>
            We declare a constant ``Raytracers`` within the scripting language which
            is then linked with the object. This is done using ``module-&gt;add_global_const``.
          </li>
          <li>
            Next, we must expose each member function in turn. This is achieved
            with ``module-&gt;add``. Since the syntax is not trivial
            and this needs to be done for each ray tracer version,
            we defined a macro ``BIND`` that takes most of the syntactic burden
            away from us: if ``RaytracerLibrary`` has a member function F,
            you can expose it using ``BIND(F)``.
          </li>
        </ol>
        <p>
          We do not put all factories within packages, as it would become too much of a syntactic
          burden for often used factories. For example, primitives can be created
          using top level functions, i.e. you simply write ``sphere()`` instead
          of ``Primitives.sphere()``.
        </p>
        <p>
          An example of how to export something as a top level function is ``create_scene``.
          In C++, ``create_scene`` is a top level function. ``module-&gt;add`` recognizes
          this fact and mirrors it by exposing ``create_scene`` as a top level function inside the scripting language.
        </p>
        <aside class="boxed2">
          <h1>Task</h1>
          <p>
            Add a binding for ``v1``.
          </p>
          <p>
            Examine the ``v(int)`` function and update it as necessary.
          </p>
          <p>
            Check your work by creating a script that uses ray tracer v1 and rendering it.
          </p>
        </aside>
      </section>
    </div>
  </body>

  <script>
    function initialize()
    {
      SourceEditor.initialize();
    }

    $( initialize );   
  </script>
</html>
