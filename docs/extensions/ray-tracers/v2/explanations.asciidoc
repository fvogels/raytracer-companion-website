= Ray Tracer v2

[overview]
----
difficulty 2
requires ray-tracers/v1
reading lighting/diffuse
----

preview::preview[]

== Implementation

<</extensions/ray-tracers/v1/explanations#,Ray tracer v1>> added support for <</reference/lighting/ambient/explanations#,ambient lighting>>.
This ray tracer adds another kind of lighting, namely <</reference/lighting/diffuse/explanations#,diffuse lighting>>. Take some time to read up on it.

When ray tracing a scene, our goal is to be able to simulate each photon so that we know which effect it has on
our final image. Ray tracer v1 only took into consideration a small fraction of these photons,
namely only those due to ambient lighting. Ray tracer v2 will also take into account photons that
are the product of diffuse lighting.

[stem]
++++
  \begin{array}{rcl}
    \textrm{v1} & = & \textrm{ambient photons} \\
    \textrm{v2} & = & \textrm{ambient photons} + \sum_{L \in \textrm{lights}} \textrm{diffuse photons from } L \\
  \end{array}
++++

`RayTracerV2` will be structured as follows (red indicates new additions compared to `v1`):

image::code-structure.svg[align="center"]

We now discuss each of the methods' responsibilities in turn.

[NOTE]
====
This may come across as a lot of unnecessary indirections, but we're simply giving each method one responsibility.
Future ray tracers will reap the rewards: implementing them will be a matter of overriding the appropriate method.
====

=== Setting Things Up

[TASK]
====
Create two new files ``raytracers/ray-tracer-v2.cpp`` and ``raytracers/ray-tracer-v2.h``.
Add a class declaration for `RayTracerV2`.
The class must inherit from `RayTracerV1`.
====

=== determine_color

[TASK]
====
`RayTracerV2` must override `determine_color`.

* Add a declaration for `determine_color` in the `.h` file.
  Remember to add the `override` specifier.
* Create an empty-bodied definition in the `.cpp` file.
====

The `v1` version of `determine_color` simply returns `compute_ambient`.
`v2` will add diffuse lighting to this.

[TASK]
====
Implement `RayTracerv2::determine_color` using the pseudocode below as guide:

[source,language='python']
----
def determine_color(scene, matprops, hit, eye_ray):
  result = black

  # Call old version of determine_color
  result += super().determine_color(scene, matprops, hit, eye_ray)

  # Process all lights in the scene
  result += process_lights(scene, matprops, hit, eye_ray)

  return result
----

You may have to look up how to call the superclass's version of a method in {cpp}.
====

=== process_lights

This method's sole responsibility is to iterate over each light and return the sum of all the returned colors.

[TASK]
====
Create a declaration (in `.h`) and definition (in `.cpp`) for ``RayTracerV2::process_lights``.

[source,language='python']
----
def process_lights(scene, matprops, hit, eye_ray):
  result = black

  for light_source in scene.light_sources:
    result += process_light_source(scene, matprops, hit, eye_ray, light_source)

  return result
----

* Think of const-correctness.
* Make it overridable.
====

=== process_light_source

This method asks the given light source to enumerate all light rays it emits in the direction of the hit position
and passes each to ``process_light_ray``.
For point lights, there is only one such ray, but area lights can produce many.

[%header,.center,cols="^,^"]
|===
| Point Light | Area Light
| image:point-light.png[]
| image:area-light.png[]
|===

Note how light sources produce ``LightRay`` objects, not just ``Ray``s. A ``LightRay``
is a ``Ray`` combined with a ``Color``, meaning it specifies not only where the light comes from,
but also which color it is.

[TASK]
====
Create a declaration (in `.h`) and definition (in `.cpp`) for ``RayTracerV2::process_light_source``.

[source,language='python']
----
def process_light_source(scene, matprops, hit, eye_ray, light_source):
  result = black

  for light_ray in light_source.lightrays_to(hit.position):
    result += process_light_ray(scene, matprops, hit, eye_ray, light_ray)

  return result
----

* Think of const-correctness.
* Make it overridable.
====

=== process_light_ray

[TASK]
====
Create a declaration (in `.h`) and definition (in `.cpp`) for ``RayTracerV2::process_light_ray``.

[source,language='python']
----
def process_light_ray(scene, matprops, hit, eye_ray, light_ray):
  result = black

  result += compute_diffuse(matprops, hit, eye_ray, light_ray)

  return result
----

* Think of const-correctness.
* Make it overridable.
====

=== compute_diffuse

Finally comes the time to actually compute diffuse lighting.
The arguments provide you with all necessary data. You need:

* The direction of the incoming light.
* The light's color.
* The position to be lit.
* The normal vector at the position to be lit.

[TASK]
====
Translate the <</reference/lighting/diffuse/explanations#,mathematical formula for diffuse lighting>> into code.

[source,language='python']
----
def compute_diffuse(matprops, hit, eye_ray, light_ray):
  # First extract all information from arguments
  n = ...
  L = ...
  P = ...
  CL = ...
  CS = ...

  cos = compute_cos_of_angle between n and (L-P)

  if cos > 0:
    return cos * CL * CS
  else:
    return black
----
====

[TIP]
====
* You can make use of ``Vector3D::normalized`` to normalize the vector, i.e., you can translate
+
[stem]
++++
\frac{L-P}{|L-P|}
++++
to ``(L - P).normalized()``.
* Make sure to use the right multiplication: stem:[a \cdot b] corresponds to ``a.dot(b)`` if
  both stem:[a] and stem:[b] are vectors, otherwise you need to use ``*``.
====

=== Finishing Touches

[TASK]
====
* Create the factory method ``raytracer::raytracers::v2()``.
* Add the appropriate include to ``raytracers/ray-tracers.h``.
* Update ``scripting/raytracing-module.cpp``.
====

== Evaluation

[TASK]
====
TODO
====

[NOTE]
====
Make sure that, while setting up the scene, you pick a low value for the ambient color, such as ``0.1 * colors::white()``.
For example, if you were to set ambient to ``colors::white()``, the object would already be maximally illuminated and the diffuse lighting would simply "drown" in the ambient lighting.
It's as if you point a flashlight to the sun.
====
