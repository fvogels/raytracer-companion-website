= Ray Tracer v3

[overview]
----
difficulty 2
requires ray-tracers/v2
reading lighting/specular
----

preview::preview[]

== Background Information

Ray tracer v1 gave us <</reference/lighting/ambient/explanations#,ambient lighting>>.
Ray tracer v2 improved upon this by introducing <</reference/lighting/diffuse/explanations#,diffuse lighting>>.
Ray tracer v3 will add <</reference/lighting/specular/explanations#,specular highlights>>,
which enables us to make objects look metallic.

[stem]
++++
\begin{array}{rcl}
  \textrm{v1} & = & \textrm{ambient photons} \\
  \textrm{v2} & = & \textrm{ambient photons} + \sum_{L \in \textrm{lights}} \textrm{diffuse photons from }L \\
  \textrm{v3} & = & \textrm{ambient photons} + \sum_{L \in \textrm{lights}} (\textrm{diffuse photons from } L + \textrm{specular photons from }L) \\
\end{array}
++++

== Additional Material Properties

=== MaterialProperties

[TASK]
====
Open the file `materials/material-properties.h`.
====

As you can see, the `MaterialProperties` class currently only contains fields for ambient and diffuse lighting.
We will need to add fields so that materials can also exhibit specular highlights.

[TASK]
====
In the class `MaterialProperties`,

* Add a field `specular` of type `Color`.
* Add a field `specular_exponent` of type `double`.

Add extra parameters to the constructor to be used as initial values for these fields.
====

=== MaterialPropertiesBuilder

The `MaterialProperties` class will grow large as we develop more ray tracers.
Having to specify values for each parameter will soon become cumbersome, especially since there will be reasonable default values for them.
For this reason, a `MaterialPropertiesBuilder` class exists.
It simplifies the creation of a `MaterialProperties` object:

[source,language='cpp']
----
MaterialProperties material_properties(ambient, diffuse, specular, specular_exponent);

// can be written as

auto material_properties =
  create_material_properties_with().ambient(ambient)
                                   .diffuse(diffuse)
                                   .specular(specular, specular_exponent);
----

The builder provides the following advantages:

* We can specify the arguments in any order we want.
* We can leave out any of the arguments and they will automatically be initialized to default values.
* It is much more readable as the field being initialized is being mentioned by name.
  With the regular constructor syntax, there is no hint whatsoever as to what the nth argument means.

[TASK]
====
Extend `MaterialPropertiesBuilder` with an extra method named `specular` so that it can be used to initialize ``MaterialProperties``'s fields `specular` and `specular_exponent` as follows:

[source,language='cpp']
----
// specular and specular_exponent belong together,
// so we initialize them with a single builder method
auto material_properties =
  create_material_properties_with().specular(specular, specular_exponent);
----

You can use the existing code for `ambient` and `diffuse` as a guide.
====

=== Bindings

[TASK]
====
Open `scripting/materials-module.cpp`.
Update `uniform` and `uniform_by_map` to add support for `specular` and `specular_exponent`.
Base yourself on the existing code to find out how.
====

== RayTracerV3

Ray tracer v3 will build upon v2.
In code, this is reflected by the fact that ``RayTracerV3`` should be a subclass of ``RayTracerV2``.

image::code-structure.svg[align="center"]

=== process_light_ray

Remember ``process_light_ray`` from <</extensions/ray-tracers/v2/explanations#,v2>>:
it is called once for every light ray emitted by each light source in the scene.
In the case of v2, it merely called ``compute_diffuse`` and returned that function's result.
In v3, we can override this function so that instead of only returning the diffuse color, it adds the specular highlight to this result.

[TASK]
====
Override ``RayTracerV3::process_light_ray`` using the pseudocode below as guide.

[source,language="python"]
----
def process_light_ray(scene, matprops, hit, eye_ray, light_ray):
  result = black

  result += super().process_light_ray(scene, matprops, hit, eye_ray, light_ray)
  result += compute_specular(matprops, hit, eye_ray, light_ray)

  return result
----
====

=== compute_specular

[TASK]
====
Implement the <</reference/lighting/specular/explanations#,specular highlight algorithm>> as a new _protected_ method named ``compute_specular``.

[source,language="python"]
----
def compute_specular(matprops, hit, eye_ray, light_ray):
  # Collect data from arguments
  L = ...
  P = ...
  E = ...
  CL = ...
  CP = ...
  e = ...

  # Perform computations
  i = ...
  r = ...
  v = ...
  cos_alpha = ...

  if cos_alpha > 0:
    return CL * CP * cos_alpha**e
  else:
    return black
----

[TIP]
=====
* Rely on ``Vector3D::normalized`` to normalize vectors.
* Rely on ``Vector3D::reflect_by`` to compute a reflection of a vector.
* You can optimize the function a little bit by first checking whether the ``specular`` member of the given ``MaterialProperties``
  is black. If it is, there's no point performing all calculations.
=====
====

=== Finishing Touches

[TASK]
====
Create the factory function `v3()`.
====

[TASK]
====
Expose this factory function to the scripting language by adding the necessary code in `scripting/materials-module.cpp`.
====

== Evaluation

TODO