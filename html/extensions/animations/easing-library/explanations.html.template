<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3DCG: Easing Library</title>
    <%= stylesheets('3dcg', 'box2') %>
    <%= scripts('jquery', 'jquery-ui', 'underscore', 'ace/ace', 'source-editor') %>
    <style>
      img.large {
        width: 60%;
      }

      video {
        margin: 10px auto;
      }
    </style>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
  </head>

  <body>
    <header>
      Easing Library
    </header>
    <div id="contents">
      <%= overview(reading_material: ['math/animations']) %>
      <section>
        <h1>Implementation</h1>
        <p>
          When adding bindings for primitives, materials, &hellip; the code required for exporting
          functionality to the scripting language was mostly complete: you
          only needed to add a line or two in order to make your new extension work in the scripting language.
          For easing functions, this is not the case.
        </p>

        <section>
          <h2>Easing Library</h2>
          <p>
            The scripting language works with "library objects": these are objects
            that group factory functions. Examples of such library objects are
          </p>
          <ul>
            <li>
              <code>Colors</code>, which allow you to create colors: <code>Colors.white()</code>, <code>Colors.red()</code>, &hellip;
            </li>
            <li>
              Animations
            </li>
            <li>
              Raytracers
            </li>
            <li>
              Samplers
            </li>
          </ul>
          <p>
            It is our goal to create a new library <code>Easing</code> which will group together all easing functions.
          </p>
          
          <aside class="boxed2">
            <h1>Task</h1>
            <p>
              Create the <code>EasingLibrary</code> type. The easing functions are part of
              the math module, so open <code>scripting/math-module.cpp</code>. This is where you'll need to perform the following steps.
            </p>
            <ul>
              <li>
                Define a new empty <code>struct</code> <code>EasingLibrary</code>. Put it inside the anonymous namespace
                that already exists within the file. You can take a look at <code>SamplerLibrary</code> in <code>scripting/samplers-module.cpp</code>
                or <code>RaytracerLibrary</code> in <code>scripting/raytracing-module.cpp</code> for guidance.
              </li>
              <li>
                Find the function <code>raytracer::scripting::_private_::create_math_module()</code>.
                Its responsibility is to add all math-related bindings. You can see it delegates
                this work to auxiliary functions such as <code>add_points_and_vectors</code>
                to add all <code>Point2D</code>, <code>Point3D</code>, <code>Vector2D</code> and <code>Vector3D</code> related
                functionality to the scripting language.
              </li>
              <li>
                Add an extra call to <code>add_easing</code> to this function.
              </li>
              <li>
                Define <code>add_easing</code> in the anonymous namespace. Its signature (parameter types, return type) should match the
                other functions.
              </li>
              <li>
                <code>add_easing</code> should start with creating a <code>EasingLibrary</code> object. This object
                should be created on the heap, as it survive the call to <code>add_easing</code>. This means making use
                of <code>shared_ptr</code>. For guidance, go look at <code>create_samplers_module()</code>
                in <code>scripting/samplers-module.cpp</code>.
              </li>
              <li>
                Once you created the <code>EasingLibrary</code> object, you need to expose it to the scripting language
                by associating the identifier <code>"Easing"</code> with this object. Hint: this is done using
                <code>add_global_const</code>. You can find examples of how to do it in the other scripting modules.
              </li>
              <li>
                Define a macro <code>BIND</code> that can be used to easily add
                bindings to <code>EasingLibrary</code> members. Hint: the macro makes use of the <code>add</code> member of
                Chaiscript modules.
              </li>
            </ul>
            <p>
              The <code>EasingLibrary</code> is still empty, so you cannot add bindings yet.
            </p>
          </aside>
        </section>

        <section>
          <h2>Ease function</h2>
          <p>
            Easing functions need to be applied on animations. Take a look to the preview scripts
            in the extensions for easing functions, such as bounce. You'll find that
            first, an animation from A to B is created, and then, in a second step,
            an easing function is applied to it using the <code>Animations.ease</code> function.
            You will need to define this very function in order to be able to
            make use of your easing functions.
          </p>
          <aside class="boxed2">
            <h1>Task</h1>
            <p>
              Define the <code>Animations.ease</code> function.
            </p>
            <ul>
              <li>
                Open <code>scripting/animation-module.cpp</code>.
              </li>
              <li>
                Look for the <code>AnimationLibrary</code>.
              </li>
              <li>
                Define a <a href="https://en.wikipedia.org/wiki/Template_(C%2B%2B)">function template</a> <code>ease_animation</code>.
                The template parameter <code>T</code> represents what kind of animation needs to be eased. For example,
                we can ease <code>Animation&lt;double&gt;</code>, <code>Animation&lt;Point3D&gt;</code>, <code>Animation&lt;Angle&gt;</code>,
                or any other sort of animation.
              </li>
              <li>
                The <code>ease_animation</code> function expects two parameters: an animation of type <code>Animation&lt;T&gt;</code>,
                and an easing function of type <code>math::functions::EeasingFunction</code>.
              </li>
              <li>
                The <code>ease_animation</code> function returns an <code>Animation&lt;T&gt;</code>.
              </li>
              <li>
                The body of <code>ease_animation</code> is quite simple: it calls the already existing function <code>ease</code> with the same
                parameters and returns its value. This <code>ease</code> function is defined in <code>animation/ease-animation.h</code>.
              </li>
              <li>
                Find the function <code>raytracer::scripting::_private_::create_animation_module()</code>.
              </li>
              <li>
                The scripting language itself does not support templates, so we will need to expose <code>ease_animation</code> repeatedly,
                once for each animatable type <code>T</code>. By default, your ray tracer can only animate <code>double</code>s,
                but you can also add support for <%= link 'extensions/animations/point-animation', 'point animations' %>
                and <%= link 'extensions/animations/angle-animation', 'angle animations' %>.
                For each type <code>T</code> you defined animations for, use the <code>BIND_AS</code> macro to
                expose <code>ease_animation&lt;T&gt;</code> as <code>ease</code> (e.g. <code>BIND_AS(ease_animation&lt;double&gt;, ease)</code>).
                You can reuse the same name <code>ease</code> for each <code>T</code>: the scripting language supports overloading and
                will pick automatically pick the right binding for you.
              </li>
            </ul>
          </aside>
        </section>
      </section>
    </div>
  </body>

  <script>
    function initialize()
    {
      SourceEditor.initialize();
    }

    $( initialize );   
  </script>
</html>
